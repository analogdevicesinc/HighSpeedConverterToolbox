{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) AD9081/AD9082 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) AD9988/AD9986 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9209/AD9177 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b)","title":"Overview"},{"location":"examples/","text":"Examples Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"examples/#examples","text":"Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"install/","text":"Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation. Simulation Models The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink Data Streaming with Hardware The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.","title":"Dependencies"},{"location":"install/#simulation-models","text":"The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink","title":"Simulation Models"},{"location":"install/#data-streaming-with-hardware","text":"The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Data Streaming with Hardware"},{"location":"install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"models/","text":"Behavioral Models The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"About"},{"location":"models/#behavioral-models","text":"The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Behavioral Models"},{"location":"streaming/","text":"Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Data Streaming"},{"location":"streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"support/","text":"Support Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"support/#support","text":"Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"targeting/","text":"HDL Targeting with HDL-Coder Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started","title":"HDL Targeting"},{"location":"targeting/#hdl-targeting-with-hdl-coder","text":"Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"targeting/#getting-started","text":"","title":"Getting Started"},{"location":"_pages/","text":"{% include 'header.tmpl' %} .md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) AD9081/AD9082 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) AD9988/AD9986 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9209/AD9177 ZCU102 Yes No ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b)","title":"Index"},{"location":"_pages/examples/","text":"{% include 'header.tmpl' %} Examples Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"_pages/examples/#examples","text":"Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"_pages/install/","text":"{% include 'header.tmpl' %} Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation. Simulation Models The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink Data Streaming with Hardware The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Install"},{"location":"_pages/install/#installation","text":"","title":"Installation"},{"location":"_pages/install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.","title":"Dependencies"},{"location":"_pages/install/#simulation-models","text":"The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink","title":"Simulation Models"},{"location":"_pages/install/#data-streaming-with-hardware","text":"The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Data Streaming with Hardware"},{"location":"_pages/install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"_pages/install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"_pages/install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"_pages/models/","text":"{% include 'header.tmpl' %} Behavioral Models The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Models"},{"location":"_pages/models/#behavioral-models","text":"The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Behavioral Models"},{"location":"_pages/streaming/","text":"{% include 'header.tmpl' %} Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Streaming"},{"location":"_pages/streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"_pages/streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"_pages/streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"_pages/streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"_pages/streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"_pages/support/","text":"{% include 'header.tmpl' %} Support Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"_pages/support/#support","text":"Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"_pages/targeting/","text":"{% include 'header.tmpl' %} HDL Targeting with HDL-Coder Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started","title":"Targeting"},{"location":"_pages/targeting/#hdl-targeting-with-hdl-coder","text":"Transceiver Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and transceiver based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"_pages/targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"_pages/targeting/#getting-started","text":"","title":"Getting Started"},{"location":"hdlrefdesigns/adrv9002/","text":"adrv9002 Reference Design Integration This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"adrv9002 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9002/#adrv9002-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9002 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9002/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9002/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9009/","text":"adrv9009 Reference Design Integration This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"adrv9009 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9009/#adrv9009-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9009 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9009/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9009/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9361z7035/","text":"adrv9361z7035 Reference Design Integration This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9361z7035 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9361z7035/#adrv9361z7035-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX","title":"adrv9361z7035 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9361z7035/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9361z7035/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9364z7020/","text":"adrv9364z7020 Reference Design Integration This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9364z7020 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9364z7020/#adrv9364z7020-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX","title":"adrv9364z7020 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9364z7020/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9364z7020/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9371/","text":"adrv9371 Reference Design Integration This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"adrv9371 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9371/#adrv9371-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX","title":"adrv9371 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9371/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9371/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/daq2/","text":"daq2 Reference Design Integration This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices AD9680 and AD9144 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9680_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9680_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9680_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9680_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9680_cpack/fifo_wr_data_3 16 RX DATA-IN AD9680 and AD9144 ADC Data Q0 rx_ad9680_tpl_core/adc_data_0 16 RX DATA-IN AD9680 and AD9144 ADC Data I0 rx_ad9680_tpl_core/adc_data_1 16 RX DATA-IN AD9680 and AD9144 ADC Data Q1 rx_ad9680_tpl_core/adc_data_2 16 RX DATA-IN AD9680 and AD9144 ADC Data I1 rx_ad9680_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9144_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9144_upack/fifo_rd_en 1 TX DATA-OUT AD9680 and AD9144 DAC Data Q0 ad9144_tpl_core/dac_data_0 16 TX DATA-OUT AD9680 and AD9144 DAC Data I0 ad9144_tpl_core/dac_data_1 16 TX DATA-OUT AD9680 and AD9144 DAC Data Q1 ad9144_tpl_core/dac_data_2 16 TX DATA-OUT AD9680 and AD9144 DAC Data I1 ad9144_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_ad9144_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9144_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9144_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9144_upack/fifo_rd_data_3 16 TX","title":"daq2"},{"location":"hdlrefdesigns/daq2/#daq2-reference-design-integration","text":"This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices AD9680 and AD9144 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX RX & TX","title":"daq2 Reference Design Integration"},{"location":"hdlrefdesigns/daq2/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/daq2/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9680_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9680_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9680_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9680_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9680_cpack/fifo_wr_data_3 16 RX DATA-IN AD9680 and AD9144 ADC Data Q0 rx_ad9680_tpl_core/adc_data_0 16 RX DATA-IN AD9680 and AD9144 ADC Data I0 rx_ad9680_tpl_core/adc_data_1 16 RX DATA-IN AD9680 and AD9144 ADC Data Q1 rx_ad9680_tpl_core/adc_data_2 16 RX DATA-IN AD9680 and AD9144 ADC Data I1 rx_ad9680_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9144_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9144_upack/fifo_rd_en 1 TX DATA-OUT AD9680 and AD9144 DAC Data Q0 ad9144_tpl_core/dac_data_0 16 TX DATA-OUT AD9680 and AD9144 DAC Data I0 ad9144_tpl_core/dac_data_1 16 TX DATA-OUT AD9680 and AD9144 DAC Data Q1 ad9144_tpl_core/dac_data_2 16 TX DATA-OUT AD9680 and AD9144 DAC Data I1 ad9144_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_ad9144_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9144_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9144_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9144_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/fmcomms2/","text":"fmcomms2 Reference Design Integration This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"fmcomms2 Reference Design Integration"},{"location":"hdlrefdesigns/fmcomms2/#fmcomms2-reference-design-integration","text":"This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX","title":"fmcomms2 Reference Design Integration"},{"location":"hdlrefdesigns/fmcomms2/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/fmcomms2/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/pluto/","text":"pluto Reference Design Integration This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"pluto Reference Design Integration"},{"location":"hdlrefdesigns/pluto/#pluto-reference-design-integration","text":"This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX","title":"pluto Reference Design Integration"},{"location":"hdlrefdesigns/pluto/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/pluto/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"models/ad9081/adc.tex/","text":"AD9081 ADC and ADC Mux The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact. Top-Level Control There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0 . SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used. help adi . sim . AD9081 . Rx . SampleRate SampleRate Sample Rate of ADCs Scalar in Hz. Currently this is fixed since NSD will change with this number, which would make the model invalid Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system. help adi . sim . AD9081 . Rx . Crossbar4x4Mux0 Crossbar4x4Mux0 Crossbar 4x4 Mux0 Array of input and output mapping. Index is the output and the value is the selected input Example Configuration Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only. rx = adi . sim . AD9081 . Rx ; rx . SampleRate = 4e9 ; rx . Crossbar4x4Mux0 = [ 1 , 1 , 3 , 4 ]; % Pass noise through model at 10 % and 1 % fullscale noiseVolts1 = 1.4 / 2 * 0.1 * randn ( 1000 , 1 ); noiseVolts2 = 1.4 / 2 * 0.01 * randn ( 1000 , 1 ); [ o1 , o2 , ~ , ~ , o3 , o4 ] = rx ( noiseVolts1 , noiseVolts2 , noiseVolts1 , noiseVolts1 ); outs = [ o1 , o2 , o3 , o4 ]; fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 1 ), outs (:, 2 ))) Mapped values identical 1 fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 3 ), outs (:, 4 ))) Mapped values identical 0","title":"ADC"},{"location":"models/ad9081/adc.tex/#ad9081-adc-and-adc-mux","text":"The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact.","title":"AD9081 ADC and ADC Mux"},{"location":"models/ad9081/adc.tex/#top-level-control","text":"There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0 . SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used. help adi . sim . AD9081 . Rx . SampleRate SampleRate Sample Rate of ADCs Scalar in Hz. Currently this is fixed since NSD will change with this number, which would make the model invalid Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system. help adi . sim . AD9081 . Rx . Crossbar4x4Mux0 Crossbar4x4Mux0 Crossbar 4x4 Mux0 Array of input and output mapping. Index is the output and the value is the selected input","title":"Top-Level Control"},{"location":"models/ad9081/adc.tex/#example-configuration","text":"Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only. rx = adi . sim . AD9081 . Rx ; rx . SampleRate = 4e9 ; rx . Crossbar4x4Mux0 = [ 1 , 1 , 3 , 4 ]; % Pass noise through model at 10 % and 1 % fullscale noiseVolts1 = 1.4 / 2 * 0.1 * randn ( 1000 , 1 ); noiseVolts2 = 1.4 / 2 * 0.01 * randn ( 1000 , 1 ); [ o1 , o2 , ~ , ~ , o3 , o4 ] = rx ( noiseVolts1 , noiseVolts2 , noiseVolts1 , noiseVolts1 ); outs = [ o1 , o2 , o3 , o4 ]; fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 1 ), outs (:, 2 ))) Mapped values identical 1 fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 3 ), outs (:, 4 ))) Mapped values identical 0","title":"Example Configuration"},{"location":"models/ad9081/dac.tex/","text":"AD9081 DAC The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB. Top-Level Control There are one control properties related to the DACs: SampleRate . SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used. help adi . sim . AD9081 . Tx . SampleRate SampleRate Sample Rate of DACs Scalar in Hz InverseSincGainAdjustDB Inverse Gain Adjust DB Add gain to the output signal filter. Gain is in dB and can only be >=0 but <=8.7040. This will be internally quantized based on the 8-bit allowed values with steps of 0.034dB.","title":"DAC"},{"location":"models/ad9081/dac.tex/#ad9081-dac","text":"The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB.","title":"AD9081 DAC"},{"location":"models/ad9081/dac.tex/#top-level-control","text":"There are one control properties related to the DACs: SampleRate . SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used. help adi . sim . AD9081 . Tx . SampleRate SampleRate Sample Rate of DACs Scalar in Hz InverseSincGainAdjustDB Inverse Gain Adjust DB Add gain to the output signal filter. Gain is in dB and can only be >=0 but <=8.7040. This will be internally quantized based on the 8-bit allowed values with steps of 0.034dB.","title":"Top-Level Control"},{"location":"models/ad9081/ddc2.tex/","text":"AD9081 Digital Down Converters The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed. Top-Level Control The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively. help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Rx . ChannelizerPathDecimation ChannelizerPathDecimation Channelizer Path Decimation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24] Muxing The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings. help adi . sim . AD9081 . Rx . Crossbar4x8Mux2 Crossbar4x8Mux2 Crossbar 4x8 Mux2 Array of input and output mapping. Index is the output and the value is the selected input (values should not exceed 4) NCO Mixer Enable and Modes If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. help adi . sim . AD9081 . Rx . CDDCNCOEnable CDDCNCOEnable CDDC NCO Enable 1x4 Array of booleans to enable NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOEnable FDDCNCOEnable FDDC NCO Enable 1x4 Array of booleans to enable NCOs in channelizer path NCO Frequency and Phase Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies , CDDCNCOPhases , and FDDCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage. help adi . sim . AD9081 . Rx . CDDCNCOFrequencies CDDCNCOFrequencies CDDC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOFrequencies FDDCNCOFrequencies FDDC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path Example Configuration The example below take a single input tone and shifts it into separate channels using the CDDC NCOs. rx = adi . sim . AD9081 . Rx ; % Enable 3 NCOs to shift single into different bands rx . MainDataPathDecimation = 4 ; rx . CDDCNCOEnable = [ true , true , true , false ]; rx . CDDCNCOFrequencies = [ 5e7 , - 3e7 , 1e8 , 0 ]; rx . Crossbar4x8Mux2 = [ 1 , 2 , 1 , 2 , 3 , 4 , 3 , 4 ]; % Create sinewave input sw = dsp . SineWave ; sw . Amplitude = 1.4 * 0.5 ; sw . Frequency = 100e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); [ o1 , o2 , ~ , ~ , o5 , o6 ] = rx ( data , data , data , data ); outputCodes = [ o1 , o2 , o5 , o6 ]; % Plot spectrum Nfft = length ( outputCodes ); fullscale = 2 ^ 15 ; fs = rx . SampleRate / 4 ; win = kaiser ( Nfft , 100 ); win = win / sum ( win ); win = win * Nfft ; outputCodes = double ( outputCodes ) .* win ; spec = fft ( outputCodes ) / Nfft ; spec_db = 20 * log10 ( abs ( spec ) / fullscale + 10 ^- 20 ); df = fs / Nfft ; freqRangeRx = ( - fs / 2 : df : fs / 2 - df ) . '; plot ( freqRangeRx , fftshift ( spec_db )); legend ( 'CDDC0' , 'CDDC1' , 'CDDC2' , 'CDDC3' ) xlabel ( 'Frequency (Hz)' ); ylabel ( 'Magnitude (dBFS)' );","title":"DDC"},{"location":"models/ad9081/ddc2.tex/#ad9081-digital-down-converters","text":"The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed.","title":"AD9081 Digital Down Converters"},{"location":"models/ad9081/ddc2.tex/#top-level-control","text":"The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively. help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Rx . ChannelizerPathDecimation ChannelizerPathDecimation Channelizer Path Decimation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24]","title":"Top-Level Control"},{"location":"models/ad9081/ddc2.tex/#muxing","text":"The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings. help adi . sim . AD9081 . Rx . Crossbar4x8Mux2 Crossbar4x8Mux2 Crossbar 4x8 Mux2 Array of input and output mapping. Index is the output and the value is the selected input (values should not exceed 4)","title":"Muxing"},{"location":"models/ad9081/ddc2.tex/#nco-mixer-enable-and-modes","text":"If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. help adi . sim . AD9081 . Rx . CDDCNCOEnable CDDCNCOEnable CDDC NCO Enable 1x4 Array of booleans to enable NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOEnable FDDCNCOEnable FDDC NCO Enable 1x4 Array of booleans to enable NCOs in channelizer path","title":"NCO Mixer Enable and Modes"},{"location":"models/ad9081/ddc2.tex/#nco-frequency-and-phase","text":"Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies , CDDCNCOPhases , and FDDCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage. help adi . sim . AD9081 . Rx . CDDCNCOFrequencies CDDCNCOFrequencies CDDC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOFrequencies FDDCNCOFrequencies FDDC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"NCO Frequency and Phase"},{"location":"models/ad9081/ddc2.tex/#example-configuration","text":"The example below take a single input tone and shifts it into separate channels using the CDDC NCOs. rx = adi . sim . AD9081 . Rx ; % Enable 3 NCOs to shift single into different bands rx . MainDataPathDecimation = 4 ; rx . CDDCNCOEnable = [ true , true , true , false ]; rx . CDDCNCOFrequencies = [ 5e7 , - 3e7 , 1e8 , 0 ]; rx . Crossbar4x8Mux2 = [ 1 , 2 , 1 , 2 , 3 , 4 , 3 , 4 ]; % Create sinewave input sw = dsp . SineWave ; sw . Amplitude = 1.4 * 0.5 ; sw . Frequency = 100e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); [ o1 , o2 , ~ , ~ , o5 , o6 ] = rx ( data , data , data , data ); outputCodes = [ o1 , o2 , o5 , o6 ]; % Plot spectrum Nfft = length ( outputCodes ); fullscale = 2 ^ 15 ; fs = rx . SampleRate / 4 ; win = kaiser ( Nfft , 100 ); win = win / sum ( win ); win = win * Nfft ; outputCodes = double ( outputCodes ) .* win ; spec = fft ( outputCodes ) / Nfft ; spec_db = 20 * log10 ( abs ( spec ) / fullscale + 10 ^- 20 ); df = fs / Nfft ; freqRangeRx = ( - fs / 2 : df : fs / 2 - df ) . '; plot ( freqRangeRx , fftshift ( spec_db )); legend ( 'CDDC0' , 'CDDC1' , 'CDDC2' , 'CDDC3' ) xlabel ( 'Frequency (Hz)' ); ylabel ( 'Magnitude (dBFS)' );","title":"Example Configuration"},{"location":"models/ad9081/duc.tex/","text":"AD9081 Digital Up Converters The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed. Top-Level Control The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively. help adi . sim . AD9081 . Tx . MainDataPathInterpolation MainDataPathInterpolation Main Data Path Interpolation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Tx . ChannelizerPathInterpolation ChannelizerPathInterpolation Channelizer Path Interpolation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24] Muxing The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings. help adi . sim . AD9081 . Tx . Crossbar8x8Mux Crossbar8x8Mux Crossbar 8x8 Mux Logical 4x8 array of for MainDataPath input summers. Each row corresponds to each summmer [1-4] and each column corresponds to an input Channelizer path 1-8]. Set indexes to true to enable a given path to be added into summer's output. The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0->FDUC3 and FDUC4->FDUC7). This is controlled by the columns of Crossbar8x8Mux , where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and FDUC4,FDUC5 to CDDC2: tx = adi . sim . AD9081 . Tx ; tx . Crossbar8x8Mux = [ ... 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC0 -> CDUC0 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC1 -> CDUC1 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ; ... FDUC2 -> CDUC2 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ]; % FDUC3 -> CDUC3 NCO Frequency and Phase Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies , CDUCNCOPhases , and FDUCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. help adi . sim . AD9081 . Tx . CDUCNCOFrequencies CDUCNCOFrequencies CDUC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Tx . FDUCNCOFrequencies FDUCNCOFrequencies FDUC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"DUC"},{"location":"models/ad9081/duc.tex/#ad9081-digital-up-converters","text":"The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed.","title":"AD9081 Digital Up Converters"},{"location":"models/ad9081/duc.tex/#top-level-control","text":"The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively. help adi . sim . AD9081 . Tx . MainDataPathInterpolation MainDataPathInterpolation Main Data Path Interpolation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Tx . ChannelizerPathInterpolation ChannelizerPathInterpolation Channelizer Path Interpolation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24]","title":"Top-Level Control"},{"location":"models/ad9081/duc.tex/#muxing","text":"The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings. help adi . sim . AD9081 . Tx . Crossbar8x8Mux Crossbar8x8Mux Crossbar 8x8 Mux Logical 4x8 array of for MainDataPath input summers. Each row corresponds to each summmer [1-4] and each column corresponds to an input Channelizer path 1-8]. Set indexes to true to enable a given path to be added into summer's output. The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0->FDUC3 and FDUC4->FDUC7). This is controlled by the columns of Crossbar8x8Mux , where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and FDUC4,FDUC5 to CDDC2: tx = adi . sim . AD9081 . Tx ; tx . Crossbar8x8Mux = [ ... 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC0 -> CDUC0 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC1 -> CDUC1 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ; ... FDUC2 -> CDUC2 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ]; % FDUC3 -> CDUC3","title":"Muxing"},{"location":"models/ad9081/duc.tex/#nco-frequency-and-phase","text":"Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies , CDUCNCOPhases , and FDUCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. help adi . sim . AD9081 . Tx . CDUCNCOFrequencies CDUCNCOFrequencies CDUC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Tx . FDUCNCOFrequencies FDUCNCOFrequencies FDUC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"NCO Frequency and Phase"},{"location":"models/ad9081/pfilt.tex/","text":"AD9081 Programmable FIR Filters (PFILT) Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path. There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0 Top-Level Control RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode , PFilterXTaps , and PFilterXGains . Operational Modes and Features Each PFILT block is fundamentally a large 192 tap filter which can be split into: 1 192 tap filter 2 96 tap filters 3 64 tap filters (Matrix filter only) 4 48 tap filters The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes: x1: first input x2: second input y1: first output y2: second output F1: filter 1 F2: filter 2 F3: filter 3 F4: filter 4 p: length of filters (individually) The different operational modes selectable through the PFilterXMode property are: NoFilter : y1 = x1, y2 = x2, y3 = x2, y4 = x2 SingleInphase : y1 = F1(x1), y2 = x2 SingleQuadrature : y1 = x1, y2 = F1(x2) DualReal : y1 = F1(x1), y2 = F2(x2) HalfComplexSumInphase : y1 = F1(x1)+F2(x1), y2 = x2*z^-p HalfComplexSumQuadrature : y2 = F1(x1)+F2(x1), y1 = x1*z^-p FullComplex : y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2) Matrix : y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2) Example Configuration Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs. rx = adi . sim . AD9081 . Rx ; rx . PFIREnable = 1 ; rx . PFilter1Mode = 'SingleInphase' ; rx . PFilter2Mode = 'NoFilter' ; N = 48 ; rx . PFilter1Taps = [ ones ( 1 , N ) ./ 2 ^ 3 , zeros ( 1 , 192 - N )]; rx . PFilter1TapsWidthsPerQuad = [ ... 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , ... 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , ... 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 ]; ... rampVolts = 1.0 * [( 1. / 1e3 .* ( 1 : 1e3 )) . ';(1./1e3.*(1e3:-1:1)).' ]; rampVolts = randn ( size ( rampVolts )) ./ 16 + rampVolts ; [ out1 , out2 , ~ , ~ , out3 , out4 ] = rx ( rampVolts , rampVolts , rampVolts , rampVolts ); outs = [ out1 , out2 , out3 , out4 ]; n = 1 : 2e3 ; subplot ( 2 , 1 , 1 ); plot ( n , real ( outs (:, 1 ))); title ( \"Moving Average Filter\" ) subplot ( 2 , 1 , 2 ); plot ( n , real ( outs (:, 2 ))); title ( \"No Filter\" )","title":"PFILT"},{"location":"models/ad9081/pfilt.tex/#ad9081-programmable-fir-filters-pfilt","text":"Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path. There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0","title":"AD9081 Programmable FIR Filters (PFILT)"},{"location":"models/ad9081/pfilt.tex/#top-level-control","text":"RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode , PFilterXTaps , and PFilterXGains .","title":"Top-Level Control"},{"location":"models/ad9081/pfilt.tex/#operational-modes-and-features","text":"Each PFILT block is fundamentally a large 192 tap filter which can be split into: 1 192 tap filter 2 96 tap filters 3 64 tap filters (Matrix filter only) 4 48 tap filters The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes: x1: first input x2: second input y1: first output y2: second output F1: filter 1 F2: filter 2 F3: filter 3 F4: filter 4 p: length of filters (individually) The different operational modes selectable through the PFilterXMode property are: NoFilter : y1 = x1, y2 = x2, y3 = x2, y4 = x2 SingleInphase : y1 = F1(x1), y2 = x2 SingleQuadrature : y1 = x1, y2 = F1(x2) DualReal : y1 = F1(x1), y2 = F2(x2) HalfComplexSumInphase : y1 = F1(x1)+F2(x1), y2 = x2*z^-p HalfComplexSumQuadrature : y2 = F1(x1)+F2(x1), y1 = x1*z^-p FullComplex : y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2) Matrix : y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2)","title":"Operational Modes and Features"},{"location":"models/ad9081/pfilt.tex/#example-configuration","text":"Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs. rx = adi . sim . AD9081 . Rx ; rx . PFIREnable = 1 ; rx . PFilter1Mode = 'SingleInphase' ; rx . PFilter2Mode = 'NoFilter' ; N = 48 ; rx . PFilter1Taps = [ ones ( 1 , N ) ./ 2 ^ 3 , zeros ( 1 , 192 - N )]; rx . PFilter1TapsWidthsPerQuad = [ ... 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , ... 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , ... 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 ]; ... rampVolts = 1.0 * [( 1. / 1e3 .* ( 1 : 1e3 )) . ';(1./1e3.*(1e3:-1:1)).' ]; rampVolts = randn ( size ( rampVolts )) ./ 16 + rampVolts ; [ out1 , out2 , ~ , ~ , out3 , out4 ] = rx ( rampVolts , rampVolts , rampVolts , rampVolts ); outs = [ out1 , out2 , out3 , out4 ]; n = 1 : 2e3 ; subplot ( 2 , 1 , 1 ); plot ( n , real ( outs (:, 1 ))); title ( \"Moving Average Filter\" ) subplot ( 2 , 1 , 2 ); plot ( n , real ( outs (:, 2 ))); title ( \"No Filter\" )","title":"Example Configuration"},{"location":"models/ad9081/top_level.tex/","text":"AD9081 Behavioral Model Introduction The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below: The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores. The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility. The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements. The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below. ADC and ADC Mux DAC Programmable FIR Filters (PFILT) Digital Down Converters Digital Up Converters Model Limitations The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device. Quick Start Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below: rx = adi . sim . AD9081 . Rx ; % Call constructor of Receiver model rx . MainDataPathDecimation = 4 ; % Set CDDC decimation to 4 % Call constructor with arguments rx = adi . sim . AD9081 . Rx ( 'MainDataPathDecimation' , 4 ); The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation . These properties are validated when update and at runtime so the model will not run in an undefined mode. On receive, the input data is assumed to be in volts and the output of the model will be in codes . Note that these are not strictly ADC codes depending on what processing is enable inside. We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable and should be relatively large for performance reasons. rx = adi . sim . AD9081 . Rx ; % Create sinewave at 50 % FSR sw = dsp . SineWave ; sw . Amplitude = 0.125 ; % volts sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); outputCodes = rx ( data .* 0.5 , data .* 0.5 , data .* 0.5 , data .* 1.1 ); % Plots plot ( real ( outputCodes )); xlabel ( 'Sample' ); ylabel ( 'Code' ); On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits. tx = adi . sim . AD9081 . Tx ; tx . MainDataPathInterpolation = 2 ; tx . ModeSelectMux = 0 ; % Set DAC inputs to real data from CDUCs. % Create sinewave at 50 % and 25 % FSR sw = dsp . SineWave ; sw . Amplitude = 2 ^ 15 * 0.5 ; % codes sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; dataS = sw (); data = int16 ( dataS ); dataHalf = int16 ( dataS .* 0.5 ); [ outputCodes0 , ~ , ~ , outputCodes3 ] = tx ( data , data , data , dataHalf , data , data , data , data ); % Plots plot ( real ( outputCodes0 )); hold on ; plot ( real ( outputCodes3 )); hold off ; xlabel ( 'Sample' ); ylabel ( 'Code' ); Inspecting Properties When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups: help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] rx = adi . sim . AD9081 . Rx rx = adi.sim.AD9081.Rx with properties: CDDCNCOFrequencies: [1000000 1000000 1000000 1000000] CDDCNCOEnable: [0 0 0 0] FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000] FDDCNCOEnable: [0 0 0 0 0 0 0 0] MainDataPathDecimation: 1 ChannelizerPathDecimation: 1 Crossbar4x4Mux0: [1 2 3 4] Crossbar4x8Mux2: [1 2 1 2 3 4 3 4] PFIREnable: false ModeSelectMux1: false SampleRate: 4.0000e+09 help rx . MainDataPathDecimation --- help for adi.sim.AD9081.Rx/MainDataPathDecimation --- MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6]","title":"Overview"},{"location":"models/ad9081/top_level.tex/#ad9081-behavioral-model-introduction","text":"The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below: The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores. The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility. The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements. The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below. ADC and ADC Mux DAC Programmable FIR Filters (PFILT) Digital Down Converters Digital Up Converters","title":"AD9081 Behavioral Model Introduction"},{"location":"models/ad9081/top_level.tex/#model-limitations","text":"The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device.","title":"Model Limitations"},{"location":"models/ad9081/top_level.tex/#quick-start","text":"Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below: rx = adi . sim . AD9081 . Rx ; % Call constructor of Receiver model rx . MainDataPathDecimation = 4 ; % Set CDDC decimation to 4 % Call constructor with arguments rx = adi . sim . AD9081 . Rx ( 'MainDataPathDecimation' , 4 ); The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation . These properties are validated when update and at runtime so the model will not run in an undefined mode. On receive, the input data is assumed to be in volts and the output of the model will be in codes . Note that these are not strictly ADC codes depending on what processing is enable inside. We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable and should be relatively large for performance reasons. rx = adi . sim . AD9081 . Rx ; % Create sinewave at 50 % FSR sw = dsp . SineWave ; sw . Amplitude = 0.125 ; % volts sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); outputCodes = rx ( data .* 0.5 , data .* 0.5 , data .* 0.5 , data .* 1.1 ); % Plots plot ( real ( outputCodes )); xlabel ( 'Sample' ); ylabel ( 'Code' ); On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits. tx = adi . sim . AD9081 . Tx ; tx . MainDataPathInterpolation = 2 ; tx . ModeSelectMux = 0 ; % Set DAC inputs to real data from CDUCs. % Create sinewave at 50 % and 25 % FSR sw = dsp . SineWave ; sw . Amplitude = 2 ^ 15 * 0.5 ; % codes sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; dataS = sw (); data = int16 ( dataS ); dataHalf = int16 ( dataS .* 0.5 ); [ outputCodes0 , ~ , ~ , outputCodes3 ] = tx ( data , data , data , dataHalf , data , data , data , data ); % Plots plot ( real ( outputCodes0 )); hold on ; plot ( real ( outputCodes3 )); hold off ; xlabel ( 'Sample' ); ylabel ( 'Code' );","title":"Quick Start"},{"location":"models/ad9081/top_level.tex/#inspecting-properties","text":"When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups: help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] rx = adi . sim . AD9081 . Rx rx = adi.sim.AD9081.Rx with properties: CDDCNCOFrequencies: [1000000 1000000 1000000 1000000] CDDCNCOEnable: [0 0 0 0] FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000] FDDCNCOEnable: [0 0 0 0 0 0 0 0] MainDataPathDecimation: 1 ChannelizerPathDecimation: 1 Crossbar4x4Mux0: [1 2 3 4] Crossbar4x8Mux2: [1 2 1 2 3 4 3 4] PFIREnable: false ModeSelectMux1: false SampleRate: 4.0000e+09 help rx . MainDataPathDecimation --- help for adi.sim.AD9081.Rx/MainDataPathDecimation --- MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6]","title":"Inspecting Properties"},{"location":"sysobjects/adi.AD9081.Rx/","text":"The adi.AD9081.Rx System object is a signal source that can receive complex data from the AD9081. rx = adi.AD9081.Rx; rx = adi.AD9081.Rx('uri','ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9081 . Rx dev = adi . AD9081 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is only readable once connected to hardware ChannelNCOFrequencies + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequencies + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhases + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhases + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. TestMode + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' EnablePFIRs + Enable use of PFIR/PFILT filters PFIRFilenames + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Rx/SamplesPerFrame is inherited from superclass ADI.AD9081.BASE EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.AD9081.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9081.Rx"},{"location":"sysobjects/adi.AD9081.Tx/","text":"The adi.AD9081.Tx System object is a signal sink that can tranmsit complex data from the AD9081. tx = adi.AD9081.Tx; tx = adi.AD9081.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9081 . Tx dev = adi . AD9081 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequencies + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequencies + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhases + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhases + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScales + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. NCOEnables + Vector of logicals which enabled individual NCOs in channel interpolators SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Tx/SamplesPerFrame is inherited from superclass ADI.AD9081.BASE EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9081.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9081.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.AD9081.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = 250e6; y = swv1(); %% Send tx(y);","title":"adi.AD9081.Tx"},{"location":"sysobjects/adi.AD9361.Rx/","text":"The adi.AD9361.Rx System object is a signal source that can receive complex data from the AD9361. rx = adi.AD9361.Rx; rx = adi.AD9361.Rx('uri','ip:192.168.2.1'); AD9361 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9361 . Rx dev = adi . AD9361 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second. RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz. GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal. EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal. RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2' SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9361.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9361.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9361.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9361.Rx"},{"location":"sysobjects/adi.AD9361.Tx/","text":"The adi.AD9361.Tx System object is a signal sink that can tranmsit complex data from the AD9361. tx = adi.AD9361.Tx; tx = adi.AD9361.Tx('uri','ip:192.168.2.1'); AD9361 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9361 . Tx dev = adi . AD9361 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second. RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. RFPortSelect + 'A' 'B' SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9361.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9361.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9361.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9361.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9361.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9361.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9361.Tx"},{"location":"sysobjects/adi.AD9363.Rx/","text":"The adi.AD9363.Rx System object is a signal source that can receive complex data from the AD9364. rx = adi.AD9363.Rx; rx = adi.AD9363.Rx('uri','ip:192.168.2.1'); AD9363 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9363 . Rx dev = adi . AD9363 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9363.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9363.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9363.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9363.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9363.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9363.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9363.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.AD9363.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.AD9363.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.AD9363.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.AD9363.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.AD9363.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9363.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9363.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9363.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9363.Rx"},{"location":"sysobjects/adi.AD9363.Tx/","text":"The adi.AD9363.Tx System object is a signal sink that can transmit complex data from the AD9364. tx = adi.AD9363.Tx; tx = adi.AD9363.Tx('uri','ip:192.168.2.1'); AD9363 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9363 . Tx dev = adi . AD9363 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9363.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9363.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9363.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9363.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9363.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.AD9363.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9363.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9363.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9363.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9363.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9363.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9363.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9363.Tx"},{"location":"sysobjects/adi.AD9364.Rx/","text":"The adi.AD9361.Rx System object is a signal source that can receive complex data from the AD9364. rx = adi.AD9364.Rx; rx = adi.AD9364.Rx('uri','ip:192.168.2.1'); AD9364 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9364 . Rx dev = adi . AD9364 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9364.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9364.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9364.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9364.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9364.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.AD9364.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.AD9364.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.AD9364.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.AD9364.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.AD9364.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.AD9364.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.AD9364.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9364.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9364.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9364.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9364.Rx"},{"location":"sysobjects/adi.AD9364.Tx/","text":"The adi.AD9361.Rx System object is a signal sink that can transmit complex data from the AD9364. tx = adi.AD9364.Tx; tx = adi.AD9364.Tx('uri','ip:192.168.2.1'); AD9364 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9364 . Tx dev = adi . AD9364 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.AD9364.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.AD9364.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.AD9364.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9364.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.AD9364.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.AD9364.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9364.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9364.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9364.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9364.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9364.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9364.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9364.Tx"},{"location":"sysobjects/adi.AD9371.Rx/","text":"The adi.AD9371.Rx System object is a signal source that can receive complex data from the AD9371. rx = adi.AD9371.Rx; rx = adi.AD9371.Rx('uri','ip:192.168.2.1'); AD9371 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9371 . Rx dev = adi . AD9371 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC mode GainChannel0 + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainChannel1 + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency. LoopbackMode + Option to set digital loopback mode, specified as 0 or 1. Allows digital loopback of TX data into the RX path. Value | Mode --------------------------- 0 | Disable 1 | Enable EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9371.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9371.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.AD9371.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.AD9371.Rx"},{"location":"sysobjects/adi.AD9371.Tx/","text":"The adi.AD9371.Tx System object is a signal sink that can tranmsit complex data from the AD9371. tx = adi.AD9371.Tx; tx = adi.AD9371.Tx('uri','ip:192.168.2.1'); AD9371 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9371 . Tx dev = adi . AD9371 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9371.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.AD9371.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9371.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9371.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9371.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.AD9371.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.AD9371.Tx"},{"location":"sysobjects/adi.AD9467.Rx/","text":"The adi.AD9467.Rx System object is a signal source that can receive complex data from the AD9467. rx = adi.AD9467.Rx; rx = adi.AD9467.Rx('uri','ip:192.168.2.1'); AD9467 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9467 . Rx dev = adi . AD9467 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value read from the hardware after the object is setup. TestMode + Select ADC test mode. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn_long' 'pn_short' 'one_zero_toggle' FilterHighPass3dbFrequency + FilterHighPass3dbFrequency Scale + Scale received data. Possible options are: 0.030517 0.032043 0.033569 0.035095 0.036621 0.038146 SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9467.Rx/SamplesPerFrame is inherited from superclass ADI.AD9467.BASE EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9467.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.AD9467.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9467.Rx"},{"location":"sysobjects/adi.ADRV9002.Rx/","text":"The adi.ADRV9002.Rx System object is a signal source that can receive complex data from the ADRV9002. rx = adi.ADRV9002.Rx; rx = adi.ADRV9002.Rx('uri','ip:192.168.2.1'); ADRV9002 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9002 . Rx dev = adi . ADRV9002 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ENSMModeChannel0 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' ENSMModeChannel1 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' InterfaceGainChannel0 + This is the final gain in the digital path with possible values: -36:6:18 This gain should be selected based on primary signal bandwidth. For narrowband applications higher levels of interface gain should be used (0:18) to allow signal level and analog noise to dominate. For wideband applications this gain should be reduced or disabled since quantization noise is minimal. InterfaceGainChannel1 + This is the final gain in the digital path with possible values: -36:6:18 This gain should be selected based on primary signal bandwidth. For narrowband applications higher levels of interface gain should be used (0:18) to allow signal level and analog noise to dominate. For wideband applications this gain should be reduced or disabled since quantization noise is minimal. DigitalGainControlModeChannel0 + The digital gain control has two major purposes, one for gain correction which is to correct the small step size inaccuracy in analog front-end attenuation and the other for gain compensation which is to compensate for the entire analog front-end attenuation. The digital gain block is controlled by the Rx gain table. Different digital gain will be applied when configured in gain correction or gain compensation mode. The Rx gain table has a unique front-end attenuator setting, with a corresponding amount of digital gain, programmed at each index of the table. In the end of the Rx data path, the interface gain could be further applied by using a \u201cSlicer\u201d block for 2 major purposes. One is to avoid digital saturation in gain compensation mode. The other one is to ensure the overall SNR is limited only by analog noise and unaffected by quantization noise. Gain correction should be used when external components (LNA or DSA) does not need to be controlled. Compensation should be used for external LNA or DSA control. Gain control is specified as one of the following: 'AutomaticGainCorrection' - Automatically adjust interface gain 'ManualGainCorrection' - Manually adjust interface gain 'AutomaticGainCompensation' - Automatically adjust interface gain and external gain element 'ManualGainCompensation' - Manually adjust interface gain and external gain element DigitalGainControlModeChannel1 + The digital gain control has two major purposes, one for gain correction which is to correct the small step size inaccuracy in analog front-end attenuation and the other for gain compensation which is to compensate for the entire analog front-end attenuation. The digital gain block is controlled by the Rx gain table. Different digital gain will be applied when configured in gain correction or gain compensation mode. The Rx gain table has a unique front-end attenuator setting, with a corresponding amount of digital gain, programmed at each index of the table. In the end of the Rx data path, the interface gain could be further applied by using a \u201cSlicer\u201d block for 2 major purposes. One is to avoid digital saturation in gain compensation mode. The other one is to ensure the overall SNR is limited only by analog noise and unaffected by quantization noise. Gain correction should be used when external components (LNA or DSA) does not need to be controlled. Compensation should be used for external LNA or DSA control. Gain control is specified as one of the following: 'AutomaticGainCorrection' - Automatically adjust interface gain 'ManualGainCorrection' - Manually adjust interface gain 'AutomaticGainCompensation' - Automatically adjust interface gain and external gain element 'ManualGainCompensation' - Manually adjust interface gain and external gain element AttenuationChannel0 + Must be greater than 0 AttenuationChannel1 + Must be greater than 0 ENSMPortModeChannel0 + specified as one of the following: 'spi' 'pin' ENSMPortModeChannel1 + specified as one of the following: 'spi' 'pin' GainControllerSourceChannel0 + specified as one of the following: 'spi' 'pin' 'automatic' GainControllerSourceChannel1 + specified as one of the following: 'spi' 'pin' 'automatic' PowerdownChannel0 + PowerdownChannel1 + AGCTrackingChannel0 + AGC on the fly tracking calibration for Channel 0 AGCTrackingChannel1 + AGC on the fly tracking calibration for Channel 1 BBDCRejectionTrackingChannel0 + Baseband DC rejection on the fly tracking calibration for Channel 0 BBDCRejectionTrackingChannel1 + Baseband DC rejection on the fly tracking calibration for Channel 1 HDTrackingChannel0 + Harmonic Distortion on the fly tracking calibration for Channel 0 HDTrackingChannel1 + Harmonic Distortion on the fly tracking calibration for Channel 1 QuadratureFICTrackingChannel0 + Quadrature Error Correction Narrowband FIC on the fly tracking calibration for channel 0 QuadratureFICTrackingChannel1 + Quadrature Error Correction Narrowband FIC on the fly tracking calibration for channel 1 QuadratureWidebandPolyTrackingChannel0 + Quadrature Error Correction Wideband Poly on the fly tracking calibration for channel 0 QuadratureWidebandPolyTrackingChannel1 + Quadrature Error Correction Wideband Poly on the fly tracking calibration for channel 1 RFDCTrackingChannel0 + RF DC on the fly tracking calibration for channel 0 RFDCTrackingChannel1 + RF DC on the fly tracking calibration for channel 1 RSSITrackingChannel0 + RSSI on the fly tracking calibration for channel 0 RSSITrackingChannel1 + RSSI on the fly tracking calibration for channel 1 RSSIChannel0 + Received signal strength indicator. This valid is only valid once the object has been stepped and MATLAB connects to hardware RSSIChannel1 + Received signal strength indicator. This valid is only valid once the object has been stepped and MATLAB connects to hardware SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and other features of transceiver CustomProfileFileName + Path to custom Profile file created from profile wizard CustomStreamFileName + Path to custom stream file created from profile wizard SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This is a read-only property CenterFrequencyChannel0 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. CenterFrequencyChannel1 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. NCOCorrectionFrequencyChannel0 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. NCOCorrectionFrequencyChannel1 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9002.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9002.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9002.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9002.Rx"},{"location":"sysobjects/adi.ADRV9002.Tx/","text":"The adi.ADRV9002.Tx System object is a signal sink that can tranmsit complex data from the ADRV9002. tx = adi.ADRV9002.Tx; tx = adi.ADRV9002.Tx('uri','ip:192.168.2.1'); ADRV9002 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9002 . Tx dev = adi . ADRV9002 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ENSMModeChannel0 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' ENSMModeChannel1 + specified as one of the following: 'calibrated' 'primed' 'rf_enabled' AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB. AttenuationControlModeChannel0 + Control attenuation through: - bypass - spi - pin AttenuationControlModeChannel1 + Control attenuation through: - bypass - spi - pin PortEnableControlChannel0 + specified as one of the following: 'spi' 'pin' PortEnableControlChannel1 + specified as one of the following: 'spi' 'pin' ClosedLoopTrackingChannel0 + ClosedLoopTrackingChannel1 + LOLeakageTrackingChannel0 + LOLeakageTrackingChannel1 + LoopbackDelayTrackingChannel0 + LoopbackDelayTrackingChannel1 + PACorrectionTrackingChannel0 + PACorrectionTrackingChannel1 + QuadratureTrackingChannel0 + Quadrature Error Correction on the fly tracking calibration for channel 0 QuadratureTrackingChannel1 + Quadrature Error Correction on the fly tracking calibration for channel 1 SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and other features of transceiver CustomProfileFileName + Path to custom Profile file created from profile wizard CustomStreamFileName + Path to custom stream file created from profile wizard SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This is a read-only property CenterFrequencyChannel0 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. CenterFrequencyChannel1 + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. NCOCorrectionFrequencyChannel0 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. NCOCorrectionFrequencyChannel1 + NCO correction frequency, specified in Hz as a scalar. The default is 0. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9002.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9002.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9002.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9002.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9002.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9002.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9002.Tx"},{"location":"sysobjects/adi.ADRV9009.Rx/","text":"The adi.ADRV9009.Rx System object is a signal source that can receive complex data from the ADRV9009. rx = adi.ADRV9009.Rx; rx = adi.ADRV9009.Rx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009 . Rx dev = adi . ADRV9009 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property GainChannel0 + Channel 0 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency. GainChannel1 + Channel 1 gain, specified as a scalar from 1 dB to 30 dB. The acceptable minimum and maximum gain setting depends on the center frequency. EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableHarmonicDistortionTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnablePhaseCorrection + Option to enable phase tracking, specified as true or false. When this property is true, Phase differences between transceivers will be deterministic across power cycles and LO changes PowerdownChannel0 + Logical which will power down RX channel 0 when set PowerdownChannel1 + Logical which will power down RX channel 1 when set SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9009.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9009.Rx"},{"location":"sysobjects/adi.ADRV9009.Tx/","text":"The adi.ADRV9009.Tx System object is a signal sink that can tranmsit complex data from the ADRV9009. tx = adi.ADRV9009.Tx; tx = adi.ADRV9009.Tx('uri','ip:192.168.2.1'); ADRV9009 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9009 . Tx dev = adi . ADRV9009 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. AttenuationChannel1 + Attentuation specified as a scalar from -41.95 to 0 dB with a resolution of 0.05 dB. EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableLOLeakageTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, LO leakage compensation is applied to the transmitted signal. EnableQuadratureCalibration + Option to enable quadrature calibration on initialization, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal. EnableLOLeakageCorrection + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied EnableLOLeakageCorrectionExternal + Option to enable phase tracking, specified as true or false. When this property is true, at initialization LO leakage correction will be applied within an external loopback path. Note this requires external cabling. PowerdownChannel0 + Logical which will power down TX channel 0 when set PowerdownChannel1 + Logical which will power down TX channel 1 when set SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths EnableFrequencyHoppingModeCalibration + Option to enable frequency hopping mode VCO calibration, specified as true or false. When this property is true, at initialization VCO calibration lookup table is populated CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9009.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9009.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9009.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9009.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9009.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9009.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9009.Tx"},{"location":"sysobjects/adi.ADRV9361Z7035.Rx/","text":"The adi.ADRV9361Z7035.Rx System object is a signal source that can receive complex data from the ADRV9361Z7035. rx = adi.ADRV9361Z7035.Rx; rx = adi.ADRV9361Z7035.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9361Z7035 . Rx dev = adi . ADRV9361Z7035 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9361Z7035.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9361Z7035.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9361Z7035.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9361Z7035.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9361Z7035.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9361Z7035.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9361Z7035.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.ADRV9361Z7035.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.ADRV9361Z7035.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.ADRV9361Z7035.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9361Z7035.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9361Z7035.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9361Z7035.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9361Z7035.Rx"},{"location":"sysobjects/adi.ADRV9361Z7035.Tx/","text":"The adi.ADRV9361Z7035.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.ADRV9361Z7035.Tx; tx = adi.ADRV9361Z7035.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9361Z7035 . Tx dev = adi . ADRV9361Z7035 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9361Z7035.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9361Z7035.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9361Z7035.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9361Z7035.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9361Z7035.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.ADRV9361Z7035.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9361Z7035.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9361Z7035.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9361Z7035.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9361Z7035.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9361Z7035.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9361Z7035.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9361Z7035.Tx"},{"location":"sysobjects/adi.ADRV9364Z7020.Rx/","text":"The adi.ADRV9364Z7020.Tx System object is a signal source that can send complex data to the FMComms4. tx = adi.ADRV9364Z7020.Tx; tx = adi.ADRV9364Z7020.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9364Z7020 . Rx dev = adi . ADRV9364Z7020 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9364Z7020.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9364Z7020.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9364Z7020.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9364Z7020.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9364Z7020.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9364Z7020.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9364Z7020.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.ADRV9364Z7020.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.ADRV9364Z7020.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.ADRV9364Z7020.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9364Z7020.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9364Z7020.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9364Z7020.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9364Z7020.Rx"},{"location":"sysobjects/adi.ADRV9364Z7020.Tx/","text":"The adi.ADRV9364Z7020.Tx System object is a signal sink that can transmit complex data from the FMComms4. tx = adi.ADRV9364Z7020.Tx; tx = adi.ADRV9364Z7020.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9364Z7020 . Tx dev = adi . ADRV9364Z7020 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.ADRV9364Z7020.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.ADRV9364Z7020.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.ADRV9364Z7020.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9364Z7020.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9364Z7020.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.ADRV9364Z7020.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9364Z7020.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9364Z7020.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9364Z7020.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9364Z7020.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9364Z7020.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9364Z7020.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9364Z7020.Tx"},{"location":"sysobjects/adi.ADRV9371.Rx/","text":"The adi.ADRV9371.Rx System object is a signal source that can receive complex data from the ADRV9371. rx = adi.AD9371.Rx; rx = adi.AD9371.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9371 . Rx dev = adi . ADRV9371 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. GainControlMode + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.ADRV9371.Rx/GainControlMode is inherited from superclass ADI.AD9371.RX GainChannel0 + Channel 0 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9371.Rx/GainChannel0 is inherited from superclass ADI.AD9371.RX GainChannel1 + Channel 1 gain, specified as a scalar from -4 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.ADRV9371.Rx/GainChannel1 is inherited from superclass ADI.AD9371.RX LoopbackMode + Option to set digital loopback mode, specified as 0 or 1. Allows digital loopback of TX data into the RX path. Value | Mode --------------------------- 0 | Disable 1 | EnableHelp for adi.ADRV9371.Rx/LoopbackMode is inherited from superclass ADI.AD9371.RX EnableQuadratureTrackingChannel0 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9371.Rx/EnableQuadratureTrackingChannel0 is inherited from superclass ADI.AD9371.RX EnableQuadratureTrackingChannel1 + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.ADRV9371.Rx/EnableQuadratureTrackingChannel1 is inherited from superclass ADI.AD9371.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9371.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9371.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.ADRV9371.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.ADRV9371.Rx"},{"location":"sysobjects/adi.ADRV9371.Tx/","text":"The adi.ADRV9371.Tx System object is a signal sink that can send complex data to the ADRV9371. tx = adi.AD9371.Tx; tx = adi.AD9371.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . ADRV9371 . Tx dev = adi . ADRV9371 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9371.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9371.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.ADRV9371.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9371.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomProfile + Enable use of custom Profile file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomProfileFileName + Path to custom Profile file created from profile wizard CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.ADRV9371.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.ADRV9371.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.ADRV9371.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.ADRV9371.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.ADRV9371.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.ADRV9371.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.ADRV9371.Tx"},{"location":"sysobjects/adi.DAQ2.Rx/","text":"The adi.DAQ2.Rx System object is a signal source that can receive complex data from the DAQ2. rx = adi.DAQ2.Rx; rx = adi.DAQ2.Rx('uri','ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ2 . Rx dev = adi . DAQ2 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Rx.SamplingRate is inherited from superclass ADI.AD9680.RX EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass ADI.AD9680.BASE kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Rx/kernelBuffersCount is inherited from superclass MATLABSHARED.LIBIIO.BASE dataTypeStr + A String Representing the data typeHelp for adi.DAQ2.Rx/dataTypeStr is inherited from superclass MATLABSHARED.LIBIIO.BASE SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass ADI.AD9680.BASE Example Usage %% Rx set up rx = adi.DAQ2.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.DAQ2.Rx"},{"location":"sysobjects/adi.DAQ2.Tx/","text":"The adi.DAQ2.Tx System object is a signal source that can send complex data to the DAQ2. tx = adi.DAQ2.Tx; tx = adi.DAQ2.Tx('uri','ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ2 . Tx dev = adi . DAQ2 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Tx.SamplingRate is inherited from superclass ADI.AD9144.TX EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass ADI.AD9144.BASE kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Tx/kernelBuffersCount is inherited from superclass MATLABSHARED.LIBIIO.BASE dataTypeStr + A String Representing the data typeHelp for adi.DAQ2.Tx/dataTypeStr is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ2.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ2.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass ADI.AD9144.BASE Example Usage %% Configure device tx = adi.DAQ2.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.DAQ2.Tx"},{"location":"sysobjects/adi.FMComms2.Rx/","text":"The adi.FMComms2.Rx System object is a signal source that can receive complex data from the FMComms2. rx = adi.FMComms2.Rx; rx = adi.FMComms2.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms2 . Rx dev = adi . FMComms2 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms2.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms2.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms2.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms2.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms2.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms2.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms2.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms2.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms2.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms2.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms2.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms2.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms2.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms2.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms2.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms2.Rx"},{"location":"sysobjects/adi.FMComms2.Tx/","text":"The adi.FMComms2.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.FMComms2.Tx; tx = adi.FMComms2.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms2 . Tx dev = adi . FMComms2 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms2.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms2.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms2.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms2.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms2.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms2.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms2.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms2.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms2.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms2.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms2.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms2.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms2.Tx"},{"location":"sysobjects/adi.FMComms3.Rx/","text":"The adi.FMComms3.Rx System object is a signal source that can receive complex data from the FMComms2. rx = adi.FMComms3.Rx; rx = adi.FMComms3.Rx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms3 . Rx dev = adi . FMComms3 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms3.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms3.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms3.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms3.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms3.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms3.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms3.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms3.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms3.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms3.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms3.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms3.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms3.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms3.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms3.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms3.Rx"},{"location":"sysobjects/adi.FMComms3.Tx/","text":"The adi.FMComms3.Tx System object is a signal source that can send complex data to the FMComms2. tx = adi.FMComms3.Tx; tx = adi.FMComms3.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms3 . Tx dev = adi . FMComms3 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms3.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms3.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms3.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms3.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms3.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms3.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms3.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms3.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms3.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms3.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms3.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms3.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms3.Tx"},{"location":"sysobjects/adi.FMComms4.Rx/","text":"The adi.FMComms4.Tx System object is a signal source that can send complex data to the FMComms4. tx = adi.FMComms4.Tx; tx = adi.FMComms4.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms4 . Rx dev = adi . FMComms4 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms4.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms4.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms4.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms4.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms4.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.FMComms4.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.FMComms4.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.FMComms4.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.FMComms4.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.FMComms4.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.FMComms4.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.FMComms4.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms4.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms4.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.FMComms4.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.FMComms4.Rx"},{"location":"sysobjects/adi.FMComms4.Tx/","text":"The adi.FMComms4.Tx System object is a signal sink that can transmit complex data from the FMComms4. tx = adi.FMComms4.Tx; tx = adi.FMComms4.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . FMComms4 . Tx dev = adi . FMComms4 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.FMComms4.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.FMComms4.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.FMComms4.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms4.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.FMComms4.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.FMComms4.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.FMComms4.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.FMComms4.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.FMComms4.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.FMComms4.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.FMComms4.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.FMComms4.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.FMComms4.Tx"},{"location":"sysobjects/adi.PackRF.Rx/","text":"Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . PackRF . Rx dev = adi . PackRF . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.PackRF.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.PackRF.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.PackRF.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.PackRF.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.PackRF.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.PackRF.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.PackRF.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.PackRF.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.PackRF.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.PackRF.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.PackRF.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.PackRF.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.PackRF.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.PackRF.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.PackRF.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.PackRF.Rx"},{"location":"sysobjects/adi.PackRF.Tx/","text":"Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . PackRF . Tx dev = adi . PackRF . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.PackRF.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.PackRF.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.PackRF.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.PackRF.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.PackRF.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.PackRF.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.PackRF.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.PackRF.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.PackRF.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.PackRF.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.PackRF.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.PackRF.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.PackRF.Tx"},{"location":"sysobjects/adi.Pluto.Rx/","text":"The adi.Pluto.Tx System object is a signal source that can send complex data to the Pluto. tx = adi.Pluto.Tx; tx = adi.Pluto.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . Pluto . Rx dev = adi . Pluto . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 + Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 + specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 + Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode + Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking + Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking + Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking + Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect + 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE Example Usage %% Rx set up rx = adi.adi.Pluto.Rx.Rx('uri','ip:analog.local'); rx.CenterFrequency = 1e9; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end","title":"adi.Pluto.Rx"},{"location":"sysobjects/adi.Pluto.Tx/","text":"The adi.Pluto.Tx System object is a signal sink that can transmit complex data from the Pluto. tx = adi.Pluto.Tx; tx = adi.Pluto.Tx('uri','ip:192.168.2.1'); Product Page Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . Pluto . Tx dev = adi . Pluto . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency + RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Tx/CenterFrequency is inherited from superclass ADI.AD9361.TX SamplingRate + Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Tx/SamplingRate is inherited from superclass ADI.AD9361.TX RFBandwidth + RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Tx/RFBandwidth is inherited from superclass ADI.AD9361.TX AttenuationChannel0 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.Pluto.Tx/AttenuationChannel0 is inherited from superclass ADI.AD9361.TX AttenuationChannel1 + Attentuation specified as a scalar from -89.75 to 0 dB with a resolution of 0.25 dB.Help for adi.Pluto.Tx/AttenuationChannel1 is inherited from superclass ADI.AD9361.TX RFPortSelect + 'A' 'B'Help for adi.Pluto.Tx/RFPortSelect is inherited from superclass ADI.AD9361.TX SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter + Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName + Path to custom filter file created from filter wizard EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Tx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO + If true, connects to libIIO device during simulationHelp for adi.Pluto.Tx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.Pluto.Tx/DataSource is inherited from superclass ADI.COMMON.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSFrequencies is inherited from superclass ADI.COMMON.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSScales is inherited from superclass ADI.COMMON.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.Pluto.Tx/DDSPhases is inherited from superclass ADI.COMMON.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.Pluto.Tx/EnableCyclicBuffers is inherited from superclass ADI.COMMON.DDS Example Usage %% Configure device tx = adi.adi.Pluto.Tx; tx.uri = \"ip:analog.local\"; tx.CenterFrequency = 1e9; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); % Send tx(y);","title":"adi.Pluto.Tx"},{"location":"sysobjects/output1/","text":"adi.Pluto.Rx Receive data from Analog Devices AD9361 transceiver Description The comm.SDRRxPluto System object\u2122 is a signal source that receives data from an Analog Devices\u00ae ADALM-PLUTO radio. This connection enables you to simulate and develop various software-defined radio applications. The following diagram shows the interaction between MATLAB\u00ae, the comm.SDRRxPluto System object, and the radio hardware. Creation Syntax Properties Unless otherwise indicated, properties are nontunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName Path to custom filter file created from filter wizard EnabledChannels Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE","title":"Output1"}]}