{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) DAQ3 (AD9680/AD9152) ZC706 Yes No ADI (2021b) ZCU102 Yes No ADI (2021b) KCU105 Yes No ADI (2021b) Arria10 SoC Yes No ADI (2021b) DualAD9213 Stratix 10 Yes No ADI (2021b) AD9081/AD9082 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9083 ZCU102 Yes No ADI (2021b) AD9988/AD9986 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9177 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b) FMCJESDADC1 ZC706 Yes No ADI (2021b) FMComms11 ZC706 Yes No ADI (2021b) AD9265 ZC706 Yes No ADI (2021b) AD9434 ZC706 Yes No ADI (2021b) AD9656 ZCU102 Yes No ADI (2021b) AD9695 ZCU102 Yes No ADI (2021b) AD9739a ZC706 Yes No ADI (2021b) AD9162 ZC706 Yes No ADI (2021b) AD9164 ZC706 Yes No ADI (2021b) AD9152 ZC706 Yes No ADI (2021b)"},{"location":"ad9081/","title":"AD9081/2 Specific Features","text":""},{"location":"ad9081/#decimator-and-interpolator-configuration","title":"Decimator and Interpolator Configuration","text":"<p>By default the AD9081 MATLAB interface assumes 4 coarse and 4 fine decimation and interpolations channels are configured. This is controlled at either construction time of the adi.AD9081.Rx and adi.AD9081.Tx classes or through special hidden properties. To alter the configuration, specific arguments can be passed to the constructor. These are to set properties: - num_data_channels: Defines number of complex DMA channels - num_coarse_attr_channels: Defines number of enabled CD{D/U}Cs - num_fine_attr_channels: Defines number of enabled FD{D/U}Cs</p> <p>Note that these do not reconfigure the hardware since that but be done from the devicetree configuration.</p> <p>Below is an example of setting the coarse decimation count to use 2 CDDCs and 2 FDDCs through the constructor. <pre><code>rx = adi.AD9081.Rx(...\n'num_data_channels', 2, ...\n'num_coarse_attr_channels', 2, ...\n'num_fine_attr_channels', 2;\n)\nrx.uri = 'ip:analog'\ndata = rx();\n</code></pre></p> <p>Alternatively this configuration can be done through the properties of the created object itself: <pre><code>rx = adi.AD9081.Rx();\nrx.num_data_channels = 2;\nrx.num_coarse_attr_channels = 2;\nrx.num_fine_attr_channels = 2;\nrx.uri = 'ip:analog'\ndata = rx();\n</code></pre></p> <p>The API is identical for the TX side in reference to the interpolators, DMA, and DDS channels.</p> <p>These can be automatically determined by using the GetDataPathConfiguration method as so:</p> <pre><code>tx = adi.AD9081.Tx('uri',uri);\n[cdc, fdc, dc] = tx.GetDataPathConfiguration();\ntx = adi.AD9081.Tx(...\n'uri',uri,...\n'num_data_channels', dc, ...\n'num_coarse_attr_channels', cdc, ...\n'num_fine_attr_channels', fdc);\nrx = adi.AD9081.Rx('uri',uri);\n[cdc, fdc, dc] = rx.GetDataPathConfiguration();\nrx = adi.AD9081.Rx(...\n'uri',uri,...\n'num_data_channels', dc, ...\n'num_coarse_attr_channels', cdc, ...\n'num_fine_attr_channels', fdc);\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>Fixed-Point Designer</li> <li>(Optional) Simulink</li> </ul>"},{"location":"install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"install/#hdl-generation-support","title":"HDL Generation Support","text":"<p>To leverage HDL-Coder and the reference designs with the toolbox requires the following components:</p> <ul> <li>Xilinx Vivado 2021.1</li> <li>Xilinx SDK 2021.1</li> <li>Simulink</li> <li>HDL-Coder\u2122</li> <li>HDL Coder\u2122 Support Package for Xilinx Zynq Platform</li> </ul>"},{"location":"install/#high-speed-converter-toolbox-install","title":"High Speed Converter Toolbox Install","text":"<p>The High Speed Converter Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing High Speed Converter Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select High Speed Converter Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"models/","title":"Behavioral Models","text":"<p>The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are:</p> <ul> <li>AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC</li> </ul>"},{"location":"streaming/","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\nrx.SamplesPerFrame = 1024;\nrx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9];\ndataNCO1 = rx();\n\n% Update tunable property\nrx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9];\ndataNCO2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows:</p> <pre><code>rx = adi.DAQ2.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters:</p> <pre><code>rx.EnabledChannels = 1:16;\n</code></pre> <p>You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.</p>"},{"location":"streaming/#sending-data","title":"Sending Data","text":"<p>Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows:</p> <pre><code>tx = adi.AD9081.Tx;\n</code></pre> <p>Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data:</p> <pre><code>tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Operator method\ntx.step(tx_data); % Step method\n</code></pre> <p>However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs.</p> <p>Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows:</p> <pre><code>tx = adi.AD9081.Tx;\ntx.EnableCyclicBuffers = true;\ntx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Data will repeat forever\n</code></pre> <p>Once a vector is passed to the object with EnableCyclicBuffers set to true, the object will not accept future buffers unless first release or cleared.</p> <p>By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows:</p> <pre><code>rx.DataSource = 'DMA';\n</code></pre>"},{"location":"streaming/#dds","title":"DDS","text":"<p>Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property:</p> <pre><code>rx.DataSource = 'DDS';\n</code></pre> <p>Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows:</p> <pre><code>rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2]\nrx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1]\nrx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000]\n</code></pre> <p>Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).</p>"},{"location":"support/","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"targeting/","title":"HDL Targeting with HDL-Coder","text":"<p>High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support</p> <p></p>"},{"location":"targeting/#recommended-review","title":"Recommended Review","text":"<ul> <li>Getting started with Zynq</li> </ul>"},{"location":"targeting/#getting-started","title":"Getting Started","text":"<p>To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2021.2. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well.</p> <p>Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', 'C:\\Xilinx\\Vivado\\2021.2\\bin\\vivado.bat');\n</code></pre> <p>or Linux:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', '/opt/Xilinx/Vivado/2021.2/bin/vivado');\n</code></pre> <p>Please change the tool path if it is different on your system.</p>"},{"location":"targeting/#checking-for-supported-designs","title":"Checking For Supported Designs","text":"<p>To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command:</p> <pre><code>simulink\n</code></pre> <p>After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page.</p> <p></p> <p>After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder.</p> <p></p> <p>This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor.</p> <p></p> <p>Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:</p> <p></p>"},{"location":"targeting/#moving-bitstreams-to-hardware","title":"Moving Bitstreams To Hardware","text":"<p>Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms.</p> <p>First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here.</p> <p>Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. </p> <p></p> <p>Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.</p>"},{"location":"_pages/","title":"Index","text":"<p>{% include 'header.tmpl' %}</p> <p> <p></p> <p>ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below.</p> <p>The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet.</p> Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) DAQ3 (AD9680/AD9152) ZC706 Yes No ADI (2021b) ZCU102 Yes No ADI (2021b) KCU105 Yes No ADI (2021b) Arria10 SoC Yes No ADI (2021b) DualAD9213 Stratix 10 Yes No ADI (2021b) AD9081/AD9082 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9083 ZCU102 Yes No ADI (2021b) AD9988/AD9986 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9177 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b) FMCJESDADC1 ZC706 Yes No ADI (2021b) FMComms11 ZC706 Yes No ADI (2021b) AD9265 ZC706 Yes No ADI (2021b) AD9434 ZC706 Yes No ADI (2021b) AD9656 ZCU102 Yes No ADI (2021b) AD9695 ZCU102 Yes No ADI (2021b) AD9739a ZC706 Yes No ADI (2021b) AD9162 ZC706 Yes No ADI (2021b) AD9164 ZC706 Yes No ADI (2021b) AD9152 ZC706 Yes No ADI (2021b)"},{"location":"_pages/ad9081/","title":"Ad9081","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/ad9081/#ad90812-specific-features","title":"AD9081/2 Specific Features","text":""},{"location":"_pages/ad9081/#decimator-and-interpolator-configuration","title":"Decimator and Interpolator Configuration","text":"<p>By default the AD9081 MATLAB interface assumes 4 coarse and 4 fine decimation and interpolations channels are configured. This is controlled at either construction time of the adi.AD9081.Rx and adi.AD9081.Tx classes or through special hidden properties. To alter the configuration, specific arguments can be passed to the constructor. These are to set properties: - num_data_channels: Defines number of complex DMA channels - num_coarse_attr_channels: Defines number of enabled CD{D/U}Cs - num_fine_attr_channels: Defines number of enabled FD{D/U}Cs</p> <p>Note that these do not reconfigure the hardware since that but be done from the devicetree configuration.</p> <p>Below is an example of setting the coarse decimation count to use 2 CDDCs and 2 FDDCs through the constructor. <pre><code>rx = adi.AD9081.Rx(...\n'num_data_channels', 2, ...\n'num_coarse_attr_channels', 2, ...\n'num_fine_attr_channels', 2;\n)\nrx.uri = 'ip:analog'\ndata = rx();\n</code></pre></p> <p>Alternatively this configuration can be done through the properties of the created object itself: <pre><code>rx = adi.AD9081.Rx();\nrx.num_data_channels = 2;\nrx.num_coarse_attr_channels = 2;\nrx.num_fine_attr_channels = 2;\nrx.uri = 'ip:analog'\ndata = rx();\n</code></pre></p> <p>The API is identical for the TX side in reference to the interpolators, DMA, and DDS channels.</p> <p>These can be automatically determined by using the GetDataPathConfiguration method as so:</p> <pre><code>tx = adi.AD9081.Tx('uri',uri);\n[cdc, fdc, dc] = tx.GetDataPathConfiguration();\ntx = adi.AD9081.Tx(...\n'uri',uri,...\n'num_data_channels', dc, ...\n'num_coarse_attr_channels', cdc, ...\n'num_fine_attr_channels', fdc);\nrx = adi.AD9081.Rx('uri',uri);\n[cdc, fdc, dc] = rx.GetDataPathConfiguration();\nrx = adi.AD9081.Rx(...\n'uri',uri,...\n'num_data_channels', dc, ...\n'num_coarse_attr_channels', cdc, ...\n'num_fine_attr_channels', fdc);\n</code></pre>"},{"location":"_pages/examples/","title":"Examples","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/examples/#examples","title":"Examples","text":"<p>Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB:</p> <pre><code>doc adi\n</code></pre> <p>They can also be viewed on GitHub:</p> <ul> <li>Streaming examples</li> </ul>"},{"location":"_pages/install/","title":"Install","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/install/#installation","title":"Installation","text":""},{"location":"_pages/install/#dependencies","title":"Dependencies","text":"<p>The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.</p>"},{"location":"_pages/install/#simulation-models","title":"Simulation Models","text":"<p>The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks:</p> <ul> <li>DSP System Toolbox</li> <li>Signal Processing Toolbox</li> <li>Fixed-Point Designer</li> <li>(Optional) Simulink</li> </ul>"},{"location":"_pages/install/#data-streaming-with-hardware","title":"Data Streaming with Hardware","text":"<p>The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes:</p> <ul> <li>Communications Toolbox Support Package for Xilinx Zynq-Based Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio<ul> <li>Communications Toolbox</li> <li>Signal Processing Toolbox\u2122</li> <li>DSP System Toolbox\u2122</li> </ul> </li> <li>libiio MATLAB Binding Standalone Installer (R2021b+)<ul> <li>Signal Processing Toolbox\u2122</li> </ul> </li> </ul>"},{"location":"_pages/install/#hdl-generation-support","title":"HDL Generation Support","text":"<p>To leverage HDL-Coder and the reference designs with the toolbox requires the following components:</p> <ul> <li>Xilinx Vivado 2021.1</li> <li>Xilinx SDK 2021.1</li> <li>Simulink</li> <li>HDL-Coder\u2122</li> <li>HDL Coder\u2122 Support Package for Xilinx Zynq Platform</li> </ul>"},{"location":"_pages/install/#high-speed-converter-toolbox-install","title":"High Speed Converter Toolbox Install","text":"<p>The High Speed Converter Toolbox itself can be installed either from:</p> <ul> <li>MATLAB's Add-On Explorer </li> <li>GitHub Releases page.</li> </ul> <p>MATLAB Versions</p> <p>Before installing High Speed Converter Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer, since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page.</p>"},{"location":"_pages/install/#add-on-explorer-walkthrough","title":"Add-On Explorer Walkthrough","text":"<p>To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab:</p> <p></p> <p>Search for the toolbox:</p> <p></p> <p>Select High Speed Converter Toolbox from results:</p> <p></p> <p>Select add:</p> <p></p>"},{"location":"_pages/models/","title":"Models","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/models/#behavioral-models","title":"Behavioral Models","text":"<p>The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are:</p> <ul> <li>AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC</li> </ul>"},{"location":"_pages/streaming/","title":"Streaming","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/streaming/#receiving-and-sending-data","title":"Receiving and Sending Data","text":"<p>Remote data streaming to and from hardware is made available through system object interfaces, which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device.</p> <p>Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems.</p> <p></p> <p>Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.</p>"},{"location":"_pages/streaming/#connecting-and-configuration","title":"Connecting and Configuration","text":"<p>Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \"&lt; backend &gt;:&lt; address &gt;\", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API.</p> <p>Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\ndata = rx();\n</code></pre> With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes.</p> <p>The state of the object follows the flow of the diagram below triggered by line 3 above.</p> <p>graph LR   Z[Operator Called] --&gt;A;   A[Connect To Board] --&gt; B[Update Properties];   B --&gt; C[Initialize Buffers];   C --&gt; D[Send or Receive Data];   D --&gt; E[Lock Object];  Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: <pre><code>rx.release(); % Release object\n</code></pre></p> <p>To provide a complete example we can do more advanced configuration like so to demonstrate property changes: <pre><code>rx = adi.AD9081.Rx;\nrx.uri = 'ip:192.168.2.1';\nrx.SamplesPerFrame = 1024;\nrx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9];\ndataNCO1 = rx();\n\n% Update tunable property\nrx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9];\ndataNCO2 = rx();\n\n% Update non-tunable property\nrx.release();\nrx.SamplesPerFrame = 4096;\ndataLargerBuffer = rx();\n</code></pre></p>"},{"location":"_pages/streaming/#receiving-data","title":"Receiving Data","text":"<p>To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows:</p> <pre><code>rx = adi.DAQ2.Rx;\n</code></pre> <p>Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame.</p> <pre><code>rx.SamplesPerFrame = 1e6;\n</code></pre> <p>SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property.</p> <p>To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so:</p> <pre><code>data = rx(); % Operator method\ndata = rx.step(); % Step method\n</code></pre> <p>Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters:</p> <pre><code>rx.EnabledChannels = 1:16;\n</code></pre> <p>You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.</p>"},{"location":"_pages/streaming/#sending-data","title":"Sending Data","text":"<p>Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows:</p> <pre><code>tx = adi.AD9081.Tx;\n</code></pre> <p>Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data:</p> <pre><code>tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Operator method\ntx.step(tx_data); % Step method\n</code></pre> <p>However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs.</p> <p>Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows:</p> <pre><code>tx = adi.AD9081.Tx;\ntx.EnableCyclicBuffers = true;\ntx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1));\ntx(tx_data); % Data will repeat forever\n</code></pre> <p>Once a vector is passed to the object with EnableCyclicBuffers set to true, the object will not accept future buffers unless first release or cleared.</p> <p>By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows:</p> <pre><code>rx.DataSource = 'DMA';\n</code></pre>"},{"location":"_pages/streaming/#dds","title":"DDS","text":"<p>Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property:</p> <pre><code>rx.DataSource = 'DDS';\n</code></pre> <p>Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows:</p> <pre><code>rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2]\nrx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1]\nrx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000]\n</code></pre> <p>Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).</p>"},{"location":"_pages/support/","title":"Support","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/support/#support","title":"Support","text":"<p>Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums.</p> <p>Question regarding specific aspect of the BSP should be asked in the following places:</p> <ul> <li>Software Interface Tools for questions on the BSP itself</li> <li>Linux Software Drivers for libiio and iio driver questions</li> </ul>"},{"location":"_pages/targeting/","title":"Targeting","text":"<p>{% include 'header.tmpl' %}</p>"},{"location":"_pages/targeting/#hdl-targeting-with-hdl-coder","title":"HDL Targeting with HDL-Coder","text":"<p>High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support</p> <p></p>"},{"location":"_pages/targeting/#recommended-review","title":"Recommended Review","text":"<ul> <li>Getting started with Zynq</li> </ul>"},{"location":"_pages/targeting/#getting-started","title":"Getting Started","text":"<p>To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2021.2. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well.</p> <p>Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', 'C:\\Xilinx\\Vivado\\2021.2\\bin\\vivado.bat');\n</code></pre> <p>or Linux:</p> <pre><code>hdlsetuptoolpath('ToolName', 'Xilinx Vivado', 'ToolPath', '/opt/Xilinx/Vivado/2021.2/bin/vivado');\n</code></pre> <p>Please change the tool path if it is different on your system.</p>"},{"location":"_pages/targeting/#checking-for-supported-designs","title":"Checking For Supported Designs","text":"<p>To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command:</p> <pre><code>simulink\n</code></pre> <p>After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page.</p> <p></p> <p>After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder.</p> <p></p> <p>This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor.</p> <p></p> <p>Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:</p> <p></p>"},{"location":"_pages/targeting/#moving-bitstreams-to-hardware","title":"Moving Bitstreams To Hardware","text":"<p>Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms.</p> <p>First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here.</p> <p>Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. </p> <p></p> <p>Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.</p>"},{"location":"hdlrefdesigns/ad9081/","title":"ad9081 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9081 reference design for the Analog Devices AD9081 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9081/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9081/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_mxfe_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_mxfe_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_mxfe_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_mxfe_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_mxfe_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_mxfe_cpack/fifo_wr_data_3 16 RX DATA-OUT IP Data 4 OUT util_mxfe_cpack/fifo_wr_data_4 16 RX DATA-OUT IP Data 5 OUT util_mxfe_cpack/fifo_wr_data_5 16 RX DATA-OUT IP Data 6 OUT util_mxfe_cpack/fifo_wr_data_6 16 RX DATA-OUT IP Data 7 OUT util_mxfe_cpack/fifo_wr_data_7 16 RX DATA-IN AD9081 ADC Data 0 IN rx_mxfe_tpl_core/adc_data_0 16 RX DATA-IN AD9081 ADC Data 1 IN rx_mxfe_tpl_core/adc_data_1 16 RX DATA-IN AD9081 ADC Data 2 IN rx_mxfe_tpl_core/adc_data_2 16 RX DATA-IN AD9081 ADC Data 3 IN rx_mxfe_tpl_core/adc_data_3 16 RX DATA-IN AD9081 ADC Data 4 IN rx_mxfe_tpl_core/adc_data_4 16 RX DATA-IN AD9081 ADC Data 5 IN rx_mxfe_tpl_core/adc_data_5 16 RX DATA-IN AD9081 ADC Data 6 IN rx_mxfe_tpl_core/adc_data_6 16 RX DATA-IN AD9081 ADC Data 7 IN rx_mxfe_tpl_core/adc_data_7 16 RX VALID-IN IP Valid Tx Data IN util_mxfe_upack/fifo_rd_valid 1 TX DATA-OUT AD9081 DAC Data 0 OUT tx_mxfe_tpl_core/dac_data_0 16 TX DATA-OUT AD9081 DAC Data 1 OUT tx_mxfe_tpl_core/dac_data_1 16 TX DATA-OUT AD9081 DAC Data 2 OUT tx_mxfe_tpl_core/dac_data_2 16 TX DATA-OUT AD9081 DAC Data 3 OUT tx_mxfe_tpl_core/dac_data_3 16 TX DATA-OUT AD9081 DAC Data 4 OUT tx_mxfe_tpl_core/dac_data_4 16 TX DATA-OUT AD9081 DAC Data 5 OUT tx_mxfe_tpl_core/dac_data_5 16 TX DATA-OUT AD9081 DAC Data 6 OUT tx_mxfe_tpl_core/dac_data_6 16 TX DATA-OUT AD9081 DAC Data 7 OUT tx_mxfe_tpl_core/dac_data_7 16 TX DATA-IN IP Data 0 IN util_mxfe_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_mxfe_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_mxfe_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_mxfe_upack/fifo_rd_data_3 16 TX DATA-IN IP Data 4 IN util_mxfe_upack/fifo_rd_data_4 16 TX DATA-IN IP Data 5 IN util_mxfe_upack/fifo_rd_data_5 16 TX DATA-IN IP Data 6 IN util_mxfe_upack/fifo_rd_data_6 16 TX DATA-IN IP Data 7 IN util_mxfe_upack/fifo_rd_data_7 16 TX"},{"location":"hdlrefdesigns/ad9208/","title":"ad9208 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9208 reference design for the Analog Devices AD9208 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>VCU118</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9208/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9208/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9208_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9208_0_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9208_cpack/fifo_wr_data_0 128 RX DATA-OUT IP Data 1 OUT util_ad9208_cpack/fifo_wr_data_1 128 RX DATA-OUT IP Data 2 OUT util_ad9208_cpack/fifo_wr_data_2 128 RX DATA-OUT IP Data 3 OUT util_ad9208_cpack/fifo_wr_data_3 128 RX DATA-IN AD9208 ADC Data 0 IN rx_ad9208_0_tpl_core/adc_data_0 128 RX DATA-IN AD9208 ADC Data 1 IN rx_ad9208_0_tpl_core/adc_data_1 128 RX DATA-IN AD9208 ADC Data 2 IN rx_ad9208_1_tpl_core/adc_data_0 128 RX DATA-IN AD9208 ADC Data 3 IN rx_ad9208_1_tpl_core/adc_data_1 128 RX"},{"location":"hdlrefdesigns/ad9265/","title":"ad9265 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9265 reference design for the Analog Devices AD9265 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9265/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9265/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9265_dma/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9265/adc_valid 1 RX DATA-OUT IP Data 0 OUT axi_ad9265_dma/fifo_wr_din 16 RX DATA-IN AD9265 ADC Data 0 IN axi_ad9265/adc_data 16 RX"},{"location":"hdlrefdesigns/ad9434/","title":"ad9434 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9434 reference design for the Analog Devices AD9434 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9434/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9434/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-IN IP Valid Rx Data IN axi_ad9434/adc_valid 1 RX VALID-OUT IP Data Valid OUT axi_ad9434_dma/fifo_wr_en 1 RX DATA-IN AD9434 ADC Data 0 IN xlslice_0/Dout 12 RX DATA-IN AD9434 ADC Data 1 IN xlslice_1/Dout 12 RX DATA-IN AD9434 ADC Data 2 IN xlslice_2/Dout 12 RX DATA-IN AD9434 ADC Data 3 IN xlslice_3/Dout 12 RX DATA-OUT IP Data 0 OUT xlconcat_0/In0 12 RX DATA-OUT IP Data 1 OUT xlconcat_0/In1 12 RX DATA-OUT IP Data 2 OUT xlconcat_0/In2 12 RX DATA-OUT IP Data 3 OUT xlconcat_0/In3 12 RX"},{"location":"hdlrefdesigns/ad9739a/","title":"ad9739a Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9739a reference design for the Analog Devices AD9739A component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> </ul> </li> <li>Supported design variants:<ul> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9739a/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9739a/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant DATA-IN IP Data 0 IN xlslice_0/Dout 16 TX DATA-IN IP Data 1 IN xlslice_1/Dout 16 TX DATA-IN IP Data 2 IN xlslice_2/Dout 16 TX DATA-IN IP Data 3 IN xlslice_3/Dout 16 TX DATA-IN IP Data 4 IN xlslice_4/Dout 16 TX DATA-IN IP Data 5 IN xlslice_5/Dout 16 TX DATA-IN IP Data 6 IN xlslice_6/Dout 16 TX DATA-IN IP Data 7 IN xlslice_7/Dout 16 TX DATA-IN IP Data 8 IN xlslice_8/Dout 16 TX DATA-IN IP Data 9 IN xlslice_9/Dout 16 TX DATA-IN IP Data 10 IN xlslice_10/Dout 16 TX DATA-IN IP Data 11 IN xlslice_11/Dout 16 TX DATA-IN IP Data 12 IN xlslice_12/Dout 16 TX DATA-IN IP Data 13 IN xlslice_13/Dout 16 TX DATA-IN IP Data 14 IN xlslice_14/Dout 16 TX DATA-IN IP Data 15 IN xlslice_15/Dout 16 TX DATA-OUT AD9739A DAC Data 0 OUT xlconcat_0/In0 16 TX DATA-OUT AD9739A DAC Data 1 OUT xlconcat_0/In1 16 TX DATA-OUT AD9739A DAC Data 2 OUT xlconcat_0/In2 16 TX DATA-OUT AD9739A DAC Data 3 OUT xlconcat_0/In3 16 TX DATA-OUT AD9739A DAC Data 4 OUT xlconcat_0/In4 16 TX DATA-OUT AD9739A DAC Data 5 OUT xlconcat_0/In5 16 TX DATA-OUT AD9739A DAC Data 6 OUT xlconcat_0/In6 16 TX DATA-OUT AD9739A DAC Data 7 OUT xlconcat_0/In7 16 TX DATA-OUT AD9739A DAC Data 8 OUT xlconcat_0/In8 16 TX DATA-OUT AD9739A DAC Data 9 OUT xlconcat_0/In9 16 TX DATA-OUT AD9739A DAC Data 10 OUT xlconcat_0/In10 16 TX DATA-OUT AD9739A DAC Data 11 OUT xlconcat_0/In11 16 TX DATA-OUT AD9739A DAC Data 12 OUT xlconcat_0/In12 16 TX DATA-OUT AD9739A DAC Data 13 OUT xlconcat_0/In13 16 TX DATA-OUT AD9739A DAC Data 14 OUT xlconcat_0/In14 16 TX DATA-OUT AD9739A DAC Data 15 OUT xlconcat_0/In15 16 TX"},{"location":"hdlrefdesigns/ad9783/","title":"ad9783 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the ad9783 reference design for the Analog Devices AD9783 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/ad9783/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/ad9783/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-IN IP Valid Tx Data IN axi_ad9783/dac_valid 1 TX DATA-OUT AD9783 DAC Data 0 OUT axi_ad9783/dac_ddata_0 64 TX DATA-OUT AD9783 DAC Data 1 OUT axi_ad9783/dac_ddata_1 64 TX DATA-IN IP Data 0 IN util_ad9783_dac_upack/fifo_rd_data_0 64 TX DATA-IN IP Data 1 IN util_ad9783_dac_upack/fifo_rd_data_1 64 TX"},{"location":"hdlrefdesigns/adrv9002/","title":"adrv9002 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9002/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9002/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9009/","title":"adrv9009 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9009/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9009/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9361z7035/","title":"adrv9361z7035 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>CCBOB_CMOS</li> <li>CCBOB_LVDS</li> <li>CCBOX_LVDS</li> <li>CCFMC_LVDS</li> <li>CCPACKRF_LVDS</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9361z7035/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9361z7035/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9364z7020/","title":"adrv9364z7020 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>CCBOB_CMOS</li> <li>CCBOB_LVDS</li> <li>CCBOX_LVDS</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9364z7020/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9364z7020/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/adrv9371/","title":"adrv9371 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/adrv9371/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/adrv9371/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX"},{"location":"hdlrefdesigns/daq2/","title":"daq2 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices DAQ2 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZCU102</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/daq2/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/daq2/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9680_tpl/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT axi_ad9680_cpack/fifo_wr_data_0 64 RX DATA-OUT IP Data 1 OUT axi_ad9680_cpack/fifo_wr_data_1 64 RX DATA-IN DAQ2 ADC Data 0 IN axi_ad9680_tpl/adc_data_0 64 RX DATA-IN DAQ2 ADC Data 1 IN axi_ad9680_tpl/adc_data_1 64 RX VALID-IN IP Valid Tx Data IN axi_ad9144_upack/fifo_rd_valid 1 TX DATA-OUT DAQ2 DAC Data 0 OUT axi_ad9144_tpl/dac_data_0 64 TX DATA-OUT DAQ2 DAC Data 1 OUT axi_ad9144_tpl/dac_data_1 64 TX DATA-IN IP Data 0 IN axi_ad9144_upack/fifo_rd_data_0 64 TX DATA-IN IP Data 1 IN axi_ad9144_upack/fifo_rd_data_1 64 TX"},{"location":"hdlrefdesigns/fmcjesdadc1/","title":"fmcjesdadc1 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the fmcjesdadc1 reference design for the Analog Devices FMCJESDADC1 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZC706</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/fmcjesdadc1/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/fmcjesdadc1/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9250_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9250_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT axi_ad9250_cpack/fifo_wr_data_0 32 RX DATA-OUT IP Data 1 OUT axi_ad9250_cpack/fifo_wr_data_1 32 RX DATA-OUT IP Data 2 OUT axi_ad9250_cpack/fifo_wr_data_2 32 RX DATA-OUT IP Data 3 OUT axi_ad9250_cpack/fifo_wr_data_3 32 RX DATA-IN FMCJESDADC1 ADC Data 0 IN axi_ad9250_core/adc_data_0 32 RX DATA-IN FMCJESDADC1 ADC Data 1 IN axi_ad9250_core/adc_data_1 32 RX DATA-IN FMCJESDADC1 ADC Data 2 IN axi_ad9250_core/adc_data_2 32 RX DATA-IN FMCJESDADC1 ADC Data 3 IN axi_ad9250_core/adc_data_3 32 RX"},{"location":"hdlrefdesigns/fmcomms2/","title":"fmcomms2 Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:<ul> <li>ZED</li> <li>ZC706</li> <li>ZC702</li> </ul> </li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> <li>RX &amp; TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/fmcomms2/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/fmcomms2/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX"},{"location":"hdlrefdesigns/pluto/","title":"pluto Reference Design Integration","text":"<p>This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: </p> <ul> <li>Base reference design documentation</li> <li>Supported FPGA carriers:</li> <li>Supported design variants:<ul> <li>RX</li> <li>TX</li> </ul> </li> </ul>"},{"location":"hdlrefdesigns/pluto/#reference-design","title":"Reference Design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. <p>The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.</p>"},{"location":"hdlrefdesigns/pluto/#hdl-worflow-advisor-port-mappings","title":"HDL Worflow Advisor Port Mappings","text":"<p>When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core:</p> Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX"},{"location":"models/ad9081/adc.tex/","title":"AD9081 ADC and ADC Mux","text":"<p>The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact.</p>"},{"location":"models/ad9081/adc.tex/#top-level-control","title":"Top-Level Control","text":"<p>There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0.</p> <p>SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used.</p> <pre><code>help adi.sim.AD9081.Rx.SampleRate\n</code></pre> <pre><code>  SampleRate Sample Rate of ADCs\n    Scalar in Hz. Currently this is fixed since NSD will change\n    with this number, which would make the model invalid\n</code></pre> <p>Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system.</p> <pre><code>help adi.sim.AD9081.Rx.Crossbar4x4Mux0\n</code></pre> <pre><code>  Crossbar4x4Mux0 Crossbar 4x4 Mux0\n    Array of input and output mapping. Index is the output and the\n    value is the selected input\n</code></pre>"},{"location":"models/ad9081/adc.tex/#example-configuration","title":"Example Configuration","text":"<p>Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only.</p> <pre><code>rx = adi.sim.AD9081.Rx;\nrx.SampleRate = 4e9;\nrx.Crossbar4x4Mux0 = [1,1,3,4];\n% Pass noise through model at 10% and 1% fullscale\nnoiseVolts1 = 1.4/2*0.1*randn(1000,1);\nnoiseVolts2 = 1.4/2*0.01*randn(1000,1);\n[o1,o2,~,~,o3,o4] = rx(noiseVolts1,noiseVolts2,noiseVolts1,noiseVolts1);\nouts = [o1,o2,o3,o4];\nfprintf('Mapped values identical %d\\n',isequal(outs(:,1),outs(:,2)))\n</code></pre> <pre><code>Mapped values identical 1\n</code></pre> <pre><code>fprintf('Mapped values identical %d\\n',isequal(outs(:,3),outs(:,4)))\n</code></pre> <pre><code>Mapped values identical 0\n</code></pre>"},{"location":"models/ad9081/dac.tex/","title":"AD9081 DAC","text":"<p>The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB.</p>"},{"location":"models/ad9081/dac.tex/#top-level-control","title":"Top-Level Control","text":"<p>There are one control properties related to the DACs: SampleRate.</p> <p>SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used.</p> <pre><code>help adi.sim.AD9081.Tx.SampleRate\n</code></pre> <pre><code>  SampleRate Sample Rate of DACs\n    Scalar in Hz\n InverseSincGainAdjustDB Inverse Gain Adjust DB\n    Add gain to the output signal filter. Gain is in dB and can\n    only be &gt;=0 but &lt;=8.7040.  This will be internally quantized \n    based on the 8-bit allowed values with steps of 0.034dB.\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/","title":"AD9081 Digital Down Converters","text":"<p>The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal.</p> <p>The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed.</p>"},{"location":"models/ad9081/ddc2.tex/#top-level-control","title":"Top-Level Control","text":"<p>The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively.</p> <pre><code>help adi.sim.AD9081.Rx.MainDataPathDecimation\n</code></pre> <pre><code>  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.ChannelizerPathDecimation\n</code></pre> <pre><code>  ChannelizerPathDecimation Channelizer Path Decimation\n    Specify the decimation in the channelizer path which can be\n    [1,2,3,4,6,8,12,16,24]\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#muxing","title":"Muxing","text":"<p>The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings.</p> <pre><code>help adi.sim.AD9081.Rx.Crossbar4x8Mux2\n</code></pre> <pre><code>  Crossbar4x8Mux2 Crossbar 4x8 Mux2\n    Array of input and output mapping. Index is the output and the\n    value is the selected input (values should not exceed 4)\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#nco-mixer-enable-and-modes","title":"NCO Mixer Enable and Modes","text":"<p>If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. </p> <pre><code>help adi.sim.AD9081.Rx.CDDCNCOEnable\n</code></pre> <pre><code>  CDDCNCOEnable CDDC NCO Enable\n    1x4 Array of booleans to enable NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.FDDCNCOEnable\n</code></pre> <pre><code>  FDDCNCOEnable FDDC NCO Enable\n    1x4 Array of booleans to enable NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#nco-frequency-and-phase","title":"NCO Frequency and Phase","text":"<p>Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies, CDDCNCOPhases, and FDDCNCOPhases. The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage.</p> <pre><code>help adi.sim.AD9081.Rx.CDDCNCOFrequencies\n</code></pre> <pre><code>  CDDCNCOFrequencies CDDC NCO Frequencies\n    1x4 Array of frequencies of NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Rx.FDDCNCOFrequencies\n</code></pre> <pre><code>  FDDCNCOFrequencies FDDC NCO Frequencies\n    1x8 Array of frequencies of NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/ddc2.tex/#example-configuration","title":"Example Configuration","text":"<p>The example below take a single input tone and shifts it into separate channels using the CDDC NCOs.</p> <pre><code>rx = adi.sim.AD9081.Rx;\n% Enable 3 NCOs to shift single into different bands\nrx.MainDataPathDecimation = 4;\nrx.CDDCNCOEnable = [true,true,true,false];\nrx.CDDCNCOFrequencies = [5e7,-3e7,1e8,0];\nrx.Crossbar4x8Mux2 = [1,2,1,2,3,4,3,4];\n% Create sinewave input\nsw = dsp.SineWave;\nsw.Amplitude = 1.4*0.5;\nsw.Frequency = 100e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndata = sw();\n[o1,o2,~,~,o5,o6] = rx(data,data,data,data);\noutputCodes = [o1,o2,o5,o6];\n% Plot spectrum\nNfft = length(outputCodes); \nfullscale = 2^15; fs = rx.SampleRate/4;\nwin = kaiser(Nfft,100);\nwin = win/sum(win);\nwin = win*Nfft;\noutputCodes = double(outputCodes).*win;\nspec = fft(outputCodes) / Nfft;\nspec_db = 20*log10(abs(spec)/fullscale+10^-20);\ndf = fs/Nfft;  freqRangeRx = (-fs/2:df:fs/2-df).';\nplot(freqRangeRx,fftshift(spec_db));\nlegend('CDDC0','CDDC1','CDDC2','CDDC3')\nxlabel('Frequency (Hz)');ylabel('Magnitude (dBFS)');\n</code></pre> <p></p>"},{"location":"models/ad9081/duc.tex/","title":"AD9081 Digital Up Converters","text":"<p>The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal.</p> <p>The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed.</p>"},{"location":"models/ad9081/duc.tex/#top-level-control","title":"Top-Level Control","text":"<p>The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively.</p> <pre><code>help adi.sim.AD9081.Tx.MainDataPathInterpolation\n</code></pre> <pre><code>  MainDataPathInterpolation Main Data Path Interpolation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>help adi.sim.AD9081.Tx.ChannelizerPathInterpolation\n</code></pre> <pre><code>  ChannelizerPathInterpolation Channelizer Path Interpolation\n    Specify the decimation in the channelizer path which can be\n    [1,2,3,4,6,8,12,16,24]\n</code></pre>"},{"location":"models/ad9081/duc.tex/#muxing","title":"Muxing","text":"<p>The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings.</p> <pre><code>help adi.sim.AD9081.Tx.Crossbar8x8Mux\n</code></pre> <pre><code>  Crossbar8x8Mux Crossbar 8x8 Mux\n    Logical 4x8 array of for MainDataPath input summers. Each row\n    corresponds to each summmer [1-4] and each column corresponds\n    to an input Channelizer path 1-8]. Set indexes to true to\n    enable a given path to be added into summer's output.\n</code></pre> <p>The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0-&gt;FDUC3 and FDUC4-&gt;FDUC7). This is controlled by the columns of Crossbar8x8Mux, where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and  FDUC4,FDUC5 to CDDC2:</p> <pre><code>tx = adi.sim.AD9081.Tx;\ntx.Crossbar8x8Mux = [...\n1,0,0,0,0,0,0,0;...FDUC0-&gt;CDUC0\n0,1,0,0,0,0,0,0;...FDUC1-&gt;CDUC1\n0,0,1,0,0,0,0,0;...FDUC2-&gt;CDUC2\n0,0,0,1,0,0,0,0]; %FDUC3-&gt;CDUC3\n</code></pre>"},{"location":"models/ad9081/duc.tex/#nco-frequency-and-phase","title":"NCO Frequency and Phase","text":"<p>Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies, CDUCNCOPhases, and FDUCNCOPhases. The frequencies will be limited based on the rate going into the NCO at that stage.</p> <pre><code>help adi.sim.AD9081.Tx.CDUCNCOFrequencies\n</code></pre> <pre><code>  CDUCNCOFrequencies CDUC NCO Frequencies\n    1x4 Array of frequencies of NCOs in main data path\n</code></pre> <pre><code>help adi.sim.AD9081.Tx.FDUCNCOFrequencies\n</code></pre> <pre><code>  FDUCNCOFrequencies FDUC NCO Frequencies\n    1x8 Array of frequencies of NCOs in channelizer path\n</code></pre>"},{"location":"models/ad9081/pfilt.tex/","title":"AD9081 Programmable FIR Filters (PFILT)","text":"<p>Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path.</p> <p>There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0</p>"},{"location":"models/ad9081/pfilt.tex/#top-level-control","title":"Top-Level Control","text":"<p>RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode, PFilterXTaps, and PFilterXGains.</p>"},{"location":"models/ad9081/pfilt.tex/#operational-modes-and-features","title":"Operational Modes and Features","text":"<p>Each PFILT block is fundamentally a large 192 tap filter which can be split into:</p> <ul> <li>1 192 tap filter </li> <li>2 96 tap filters </li> <li>3 64 tap filters (Matrix filter only) </li> <li>4 48 tap filters </li> </ul> <p>The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes:</p> <ul> <li>x1: first input </li> <li>x2: second input </li> <li>y1: first output </li> <li>y2: second output </li> <li>F1: filter 1 </li> <li>F2: filter 2 </li> <li>F3: filter 3 </li> <li>F4: filter 4 </li> <li>p: length of filters (individually) </li> </ul> <p>The different operational modes selectable through the PFilterXMode property are:</p> <ul> <li>NoFilter: y1 = x1, y2 = x2, y3 = x2, y4 = x2 </li> <li>SingleInphase: y1 = F1(x1), y2 = x2 </li> <li>SingleQuadrature: y1 = x1, y2 = F1(x2) </li> <li>DualReal: y1 = F1(x1), y2 = F2(x2) </li> <li>HalfComplexSumInphase: y1 = F1(x1)+F2(x1), y2 = x2*z^-p </li> <li>HalfComplexSumQuadrature: y2 = F1(x1)+F2(x1), y1 = x1*z^-p </li> <li>FullComplex: y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2)  </li> <li>Matrix: y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2) </li> </ul>"},{"location":"models/ad9081/pfilt.tex/#example-configuration","title":"Example Configuration","text":"<p>Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs.</p> <pre><code>rx = adi.sim.AD9081.Rx;\nrx.PFIREnable = 1;\nrx.PFilter1Mode = 'SingleInphase';\nrx.PFilter2Mode = 'NoFilter';\nN = 48; rx.PFilter1Taps = [ones(1,N)./2^3,zeros(1,192-N)];\nrx.PFilter1TapsWidthsPerQuad = [...\n16,16,16,16,16,16,16,16,16,16,16,16,...\n12,12,12,12,12,12,12,12,12,12,12,12,...\n6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6];...\nrampVolts = 1.0*[(1./1e3.*(1:1e3)).';(1./1e3.*(1e3:-1:1)).'];\nrampVolts = randn(size(rampVolts))./16+rampVolts;\n[out1,out2,~,~,out3,out4] = rx(rampVolts,rampVolts,rampVolts,rampVolts);\nouts = [out1,out2,out3,out4];\nn = 1:2e3;\nsubplot(2,1,1);plot(n,real(outs(:,1)));title(\"Moving Average Filter\")\nsubplot(2,1,2);plot(n,real(outs(:,2)));title(\"No Filter\")\n</code></pre> <p></p>"},{"location":"models/ad9081/top_level.tex/","title":"AD9081 Behavioral Model Introduction","text":"<p>The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below:</p> <p></p> <p>The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores.</p> <p>The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility.</p> <p>The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements.</p> <p>The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below.</p> <ul> <li>ADC and ADC Mux </li> <li>DAC </li> <li>Programmable FIR Filters (PFILT) </li> <li>Digital Down Converters </li> <li>Digital Up Converters </li> </ul>"},{"location":"models/ad9081/top_level.tex/#model-limitations","title":"Model Limitations","text":"<p>The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device.</p>"},{"location":"models/ad9081/top_level.tex/#quick-start","title":"Quick Start","text":"<p>Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below:</p> <pre><code>rx = adi.sim.AD9081.Rx; % Call constructor of Receiver model\nrx.MainDataPathDecimation = 4; % Set CDDC decimation to 4\n% Call constructor with arguments\nrx = adi.sim.AD9081.Rx('MainDataPathDecimation',4);\n</code></pre> <p>The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation. These properties are validated when update and at runtime so the model will not run in an undefined mode.</p> <p>On receive, the input data is assumed to be in volts and the output of the model will be in codes. Note that these are not strictly ADC codes depending on what processing is enable inside.</p> <p>We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable  and should be relatively large for performance reasons.</p> <pre><code>rx = adi.sim.AD9081.Rx;\n% Create sinewave at 50% FSR\nsw = dsp.SineWave;\nsw.Amplitude = 0.125; % volts\nsw.Frequency = 10e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndata = sw();\noutputCodes = rx(data.*0.5,data.*0.5,data.*0.5,data.*1.1);\n% Plots\nplot(real(outputCodes));xlabel('Sample');ylabel('Code');\n</code></pre> <p></p> <p>On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits.</p> <pre><code>tx = adi.sim.AD9081.Tx;\ntx.MainDataPathInterpolation = 2;\ntx.ModeSelectMux = 0; % Set DAC inputs to real data from CDUCs.\n% Create sinewave at 50% and 25% FSR\nsw = dsp.SineWave;\nsw.Amplitude = 2^15*0.5; % codes\nsw.Frequency = 10e6;\nsw.SampleRate = rx.SampleRate;\nsw.SamplesPerFrame = 4e4;\ndataS = sw();\ndata = int16(dataS);dataHalf = int16(dataS.*0.5);\n[outputCodes0,~,~,outputCodes3] = tx(data,data,data,dataHalf,data,data,data,data);\n% Plots\nplot(real(outputCodes0)); hold on;\nplot(real(outputCodes3)); hold off;\nxlabel('Sample');ylabel('Code');\n</code></pre> <p></p>"},{"location":"models/ad9081/top_level.tex/#inspecting-properties","title":"Inspecting Properties","text":"<p>When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups:</p> <pre><code>help adi.sim.AD9081.Rx.MainDataPathDecimation\n</code></pre> <pre><code>  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre> <pre><code>rx = adi.sim.AD9081.Rx\n</code></pre> <pre><code>rx = \n  adi.sim.AD9081.Rx with properties:\n\n           CDDCNCOFrequencies: [1000000 1000000 1000000 1000000]\n                CDDCNCOEnable: [0 0 0 0]\n           FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000]\n                FDDCNCOEnable: [0 0 0 0 0 0 0 0]\n       MainDataPathDecimation: 1\n    ChannelizerPathDecimation: 1\n              Crossbar4x4Mux0: [1 2 3 4]\n              Crossbar4x8Mux2: [1 2 1 2 3 4 3 4]\n                   PFIREnable: false\n               ModeSelectMux1: false\n                   SampleRate: 4.0000e+09\n</code></pre> <pre><code>help rx.MainDataPathDecimation\n</code></pre> <pre><code>--- help for adi.sim.AD9081.Rx/MainDataPathDecimation ---\n\n  MainDataPathDecimation Main Data Path Decimation\n    Specify the decimation in the main data path which can be\n    [1,2,3,4,6]\n</code></pre>"},{"location":"sysobjects/adi.AD9081.Rx/","title":"adi.AD9081.Rx","text":"The adi.AD9081.Rx System object is a signal source that can receive    complex data from the AD9081.     rx = adi.AD9081.Rx;    rx = adi.AD9081.Rx('uri','ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9081.Rx\ndev = adi.AD9081.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is only readable once connected to hardware</p> ChannelNCOFrequencies + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequencies + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhases + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhases + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> TestMode + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> EnablePFIRs + <p>Enable use of PFIR/PFILT filters</p> PFIRFilenames + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Rx/SamplesPerFrame is inherited from superclass adi.AD9081.Base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD9081.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD9081.Tx/","title":"adi.AD9081.Tx","text":"The adi.AD9081.Tx System object is a signal sink that can tranmsit    complex data from the AD9081.     tx = adi.AD9081.Tx;    tx = adi.AD9081.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9081.Tx\ndev = adi.AD9081.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequencies + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequencies + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhases + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhases + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScales + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> NCOEnables + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Tx/SamplesPerFrame is inherited from superclass adi.AD9081.Base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Tx/uri is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9081.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9081.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD9081.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.ComplexOutput = true;\nswv1.SamplesPerFrame = 2^14;\nswv1.SampleRate = 250e6;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD9083.Rx/","title":"adi.AD9083.Rx","text":"The adi.AD9083.Rx System object is a signal source that can receive    data from the AD9083.     rx = adi.AD9083.Rx;    rx = adi.AD9083.Rx('uri','ip:192.168.2.1'); AD9083 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9083.Rx\ndev = adi.AD9083.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9083.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9083.Rx/SamplesPerFrame is inherited from superclass adi.AD9083.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD9083.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD9083.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9083.Rx/SamplesPerFrame is inherited from superclass adi.AD9083.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD9083.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD9144.Tx/","title":"adi.AD9144.Tx","text":"The adi.AD9144.Tx System object is a signal source that can send    complex data from the AD9144.     tx = adi.AD9144.Tx;    tx = adi.AD9144.Tx('uri','ip:192.168.2.1'); AD9144 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9144.Tx\ndev = adi.AD9144.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9144.Tx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9144.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD9144.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD9144.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9144.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9144.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9144.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD9144.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD9152.Tx/","title":"adi.AD9152.Tx","text":"The adi.AD9152.Tx System object is a signal source that can send    complex data from the AD9144.     tx = adi.AD9144.Tx;    tx = adi.AD9144.Tx('uri','ip:ip:192.168.2.1'); AD9144 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9152.Tx\ndev = adi.AD9152.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9152.Tx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9152.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD9152.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD9152.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9152.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9152.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9152.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base</p> Example Usage <pre><code>%% Configure device\ntx = adi.AD9152.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.AD9213.Rx/","title":"adi.AD9213.Rx","text":"The adi.AD9213.Rx System object is a signal source that can receive    complex data from the AD9213.     rx = adi.AD9213.Rx;    rx = adi.AD9213.Rx('uri','ip:192.168.2.1'); AD9213 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9213.Rx\ndev = adi.AD9213.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9213.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD9213.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD9213.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD9213.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD9467.Rx/","title":"adi.AD9467.Rx","text":"The adi.AD9467.Rx System object is a signal source that can receive    complex data from the AD9467.     rx = adi.AD9467.Rx;    rx = adi.AD9467.Rx('uri','ip:192.168.2.1'); AD9467 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9467.Rx\ndev = adi.AD9467.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value read from the hardware after the object is setup.</p> TestMode + <p>Select ADC test mode. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn_long' 'pn_short' 'one_zero_toggle'</p> FilterHighPass3dbFrequency + <p>FilterHighPass3dbFrequency</p> Scale + <p>Scale received data. Possible options are: 0.030517 0.032043 0.033569 0.035095 0.036621 0.038146</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9467.Rx/SamplesPerFrame is inherited from superclass adi.AD9467.Base</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9467.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD9467.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.AD9680.Rx/","title":"adi.AD9680.Rx","text":"The adi.AD9680.Rx System object is a signal source that can receive    complex data from the AD9680.     rx = adi.AD9680.Rx;    rx = adi.AD9680.Rx('uri','ip:192.168.2.1'); AD9680 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.AD9680.Rx\ndev = adi.AD9680.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.AD9680.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9680.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.AD9680.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.AD9680.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9680.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.AD9680.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.DAQ2.Rx/","title":"adi.DAQ2.Rx","text":"The adi.DAQ2.Rx System object is a signal source that can     receive complex data from the DAQ2.     rx = adi.DAQ2.Rx;    rx = adi.DAQ2.Rx('uri','ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ2.Rx\ndev = adi.DAQ2.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Rx/SamplingRate is inherited from superclass adi.AD9680.Rx</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ2.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.DAQ2.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.DAQ2.Tx/","title":"adi.DAQ2.Tx","text":"The adi.DAQ2.Tx System object is a signal source that can     send complex data to the DAQ2.     tx = adi.DAQ2.Tx;    tx = adi.DAQ2.Tx('uri','ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ2.Tx\ndev = adi.DAQ2.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Tx.SamplingRate is inherited from superclass adi.AD9144.Tx</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Tx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ2.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ2.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ2.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base</p> Example Usage <pre><code>%% Configure device\ntx = adi.DAQ2.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.DAQ3.Rx/","title":"adi.DAQ3.Rx","text":"The adi.DAQ3.Rx System object is a signal source that can     receive complex data from the DAQ3.     rx = adi.DAQ3.Rx;    rx = adi.DAQ3.Rx('uri','ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ3.Rx\ndev = adi.DAQ3.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ3.Rx/SamplingRate is inherited from superclass adi.AD9680.Rx</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ3.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ3.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ3.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.DAQ3.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.DAQ3.Tx/","title":"adi.DAQ3.Tx","text":"The adi.DAQ2.Tx System object is a signal source that can     send complex data to the DAQ3.     tx = adi.DAQ3.Tx;    tx = adi.DAQ3.Tx('uri','ip:ip:192.168.2.1'); User Guide Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DAQ3.Tx\ndev = adi.DAQ3.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + <p>Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ3.Tx/SamplingRate is inherited from superclass adi.AD9152.Tx</p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DAQ3.Tx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ3.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DAQ3.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ3.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ3.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base</p> Example Usage <pre><code>%% Configure device\ntx = adi.DAQ3.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/adi.DualAD9213.Rx/","title":"adi.DualAD9213.Rx","text":"The adi.DualAD9213.Rx System object is a signal source that can receive    complex data from the DualAD9213.     rx = adi.DualAD9213.Rx;    rx = adi.DualAD9213.Rx('uri','ip:ip:192.168.2.1'); AD9213 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.DualAD9213.Rx\ndev = adi.DualAD9213.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.DualAD9213.Rx/uri is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DualAD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base</p> kernelBuffersCount + <p>The number of buffers allocated in the kernel for data transfersHelp for adi.DualAD9213.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base</p> dataTypeStr + <p>A String Representing the data typeHelp for adi.DualAD9213.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DualAD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.DualAD9213.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.QuadMxFE.Rx/","title":"adi.QuadMxFE.Rx","text":"The adi.QuadMxFE.Rx System object is a signal source that can receive    complex data from the QuadMxFE.     rx = adi.QuadMxFE.Rx;    rx = adi.QuadMxFE.Rx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.QuadMxFE.Rx\ndev = adi.QuadMxFE.Rx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequenciesChipA + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOFrequenciesChipB + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOFrequenciesChipC + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOFrequenciesChipD + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequenciesChipA + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequenciesChipB + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequenciesChipC + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOFrequenciesChipD + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhasesChipA + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhasesChipB + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhasesChipC + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> ChannelNCOPhasesChipD + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhasesChipA + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhasesChipB + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhasesChipC + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> MainNCOPhasesChipD + <p>Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available.</p> TestModeChipA + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> TestModeChipB + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> TestModeChipC + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> TestModeChipD + <p>Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp'</p> EnablePFIRsChipA + <p>Enable use of PFIR/PFILT filters for Chip A</p> EnablePFIRsChipB + <p>Enable use of PFIR/PFILT filters for Chip B</p> EnablePFIRsChipC + <p>Enable use of PFIR/PFILT filters for Chip C</p> EnablePFIRsChipD + <p>Enable use of PFIR/PFILT filters for Chip D</p> PFIRFilenamesChipA + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip A</p> PFIRFilenamesChipB + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip B</p> PFIRFilenamesChipC + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip C</p> PFIRFilenamesChipD + <p>Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip D</p> ExternalAttenuation + <p>Attenuation value of external HMC425a</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.</p> EnableResampleFilters + <p>Enable interpolation (TX) or decimation (RX) by 2 when enabled to correct interface rate to 125 MS/s. This will scale the input and output data length by either 1/2 (RX) or 2 (TX).</p> CalibrationBoardAttached + <p></p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.QuadMxFE.Rx/uri is inherited from superclass matlabshared.libiio.base</p> Example Usage <pre><code>%% Rx set up\nrx = adi.QuadMxFE.Rx('uri','ip:analog.local');\nrx.SamplesPerFrame = 2^14;\nrx.EnabledChannels = 1;\n\n%% Run\nfor k=1:10\n    valid = false;\n    while ~valid\n        [out, valid] = rx();\n    end\nend\n\n%% Cleanup\nrelease(rx)\n</code></pre>"},{"location":"sysobjects/adi.QuadMxFE.Tx/","title":"adi.QuadMxFE.Tx","text":"The adi.QuadMxFE.Tx System object is a signal sink that can tranmsit    complex data from the QuadMxFE.     tx = adi.QuadMxFE.Tx;    tx = adi.QuadMxFE.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation <p>The class can be instantiated in the following way with and without property name value pairs.</p> <pre><code>dev = adi.QuadMxFE.Tx\ndev = adi.QuadMxFE.Tx(Name, Value)\n</code></pre> Properties  Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequenciesChipA + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOFrequenciesChipB + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOFrequenciesChipC + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOFrequenciesChipD + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequenciesChipA + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequenciesChipB + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequenciesChipC + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOFrequenciesChipD + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhasesChipA + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhasesChipB + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhasesChipC + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOPhasesChipD + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhasesChipA + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhasesChipB + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhasesChipC + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> MainNCOPhasesChipD + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScalesChipA + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScalesChipB + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScalesChipC + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> ChannelNCOGainScalesChipD + <p>Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz.</p> NCOEnablesChipA + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> NCOEnablesChipB + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> NCOEnablesChipC + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> NCOEnablesChipD + <p>Vector of logicals which enabled individual NCOs in channel interpolators</p> UpdateDACFullScaleCurrent + <p>At initialization update DAC full scale current</p> DACFullScaleCurrentuA + <p>DAC full scale current in microamps. Only used when UpdateDACFullScaleCurrent is set.</p> SamplesPerFrame + <p>Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.</p> EnableResampleFilters + <p>Enable interpolation (TX) or decimation (RX) by 2 when enabled to correct interface rate to 125 MS/s. This will scale the input and output data length by either 1/2 (RX) or 2 (TX).</p> CalibrationBoardAttached + <p></p> EnabledChannels + <p>Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant</p> uri + <p>Hostname or IP address of remote libIIO deviceHelp for adi.QuadMxFE.Tx/uri is inherited from superclass matlabshared.libiio.base</p> DataSource + <p>Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.QuadMxFE.Tx/DataSource is inherited from superclass adi.common.DDS</p> DDSFrequencies + <p>Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSFrequencies is inherited from superclass adi.common.DDS</p> DDSScales + <p>Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSScales is inherited from superclass adi.common.DDS</p> DDSPhases + <p>Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N &lt; this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSPhases is inherited from superclass adi.common.DDS</p> EnableCyclicBuffers + <p>Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.QuadMxFE.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS</p> Example Usage <pre><code>%% Configure device\ntx = adi.QuadMxFE.Tx;\ntx.uri = \"ip:analog.local\";\ntx.DataSource = 'DMA';\ntx.EnableCyclicBuffers = true;\ntx.EnabledChannels = 1;\n\n%% Generate tone\namplitude = 2^15; frequency = 0.12e6;\nswv1 = dsp.SineWave(amplitude, frequency);\nswv1.SamplesPerFrame = 2^14;\n\nswv1.SampleRate = tx.SamplingRate;\ny = swv1();\n\n%% Send\ntx(y);\n</code></pre>"},{"location":"sysobjects/output1/","title":"Output1","text":"adi.Pluto.Rx  Receive data from Analog Devices AD9361 transceiver  Description  The comm.SDRRxPluto System object\u2122 is a signal source that receives data from an Analog Devices\u00ae ADALM-PLUTO radio. This connection enables you to simulate and develop various software-defined radio applications.  The following diagram shows the interaction between MATLAB\u00ae, the comm.SDRRxPluto System object, and the radio hardware.   Creation <p>Syntax</p> Properties  Unless otherwise indicated, properties are nontunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them.  If a property is tunable, you can change its value at any time.  For more information on changing property values, see System Design in MATLAB Using System Objects."},{"location":"sysobjects/output1/#headingTwo","title":"CenterFrequency","text":"RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"SamplingRate","text":"Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"RFBandwidth","text":"RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainControlModeChannel0","text":"specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainChannel0","text":"Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainControlModeChannel1","text":"specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"GainChannel1","text":"Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"LoopbackMode","text":"Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value  | Mode ---------------------------  0 |  Disable  1 |  Digital TX -&gt; Digital RX  2 |  RF RX -&gt; RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableQuadratureTracking","text":"Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableRFDCTracking","text":"Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"EnableBasebandDCTracking","text":"Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"RFPortSelect","text":"'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX"},{"location":"sysobjects/output1/#headingTwo","title":"SamplesPerFrame","text":"Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance."},{"location":"sysobjects/output1/#headingTwo","title":"EnableCustomFilter","text":"Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths"},{"location":"sysobjects/output1/#headingTwo","title":"CustomFilterFileName","text":"Path to custom filter file created from filter wizard"},{"location":"sysobjects/output1/#headingTwo","title":"EnabledChannels","text":"Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant"},{"location":"sysobjects/output1/#headingTwo","title":"uri","text":"Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE"},{"location":"sysobjects/output1/#headingTwo","title":"enIO","text":"If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE"}]}