{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":".md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) DAQ3 (AD9680/AD9152) ZC706 Yes No ADI (2021b) ZCU102 Yes No ADI (2021b) KCU105 Yes No ADI (2021b) Arria10 SoC Yes No ADI (2021b) DualAD9213 Stratix 10 Yes No ADI (2021b) AD9081/AD9082 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9083 ZCU102 Yes No ADI (2021b) AD9988/AD9986 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9177 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b)","title":"Overview"},{"location":"examples/","text":"Examples Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"examples/#examples","text":"Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"install/","text":"Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation. Simulation Models The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink Data Streaming with Hardware The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.","title":"Dependencies"},{"location":"install/#simulation-models","text":"The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink","title":"Simulation Models"},{"location":"install/#data-streaming-with-hardware","text":"The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Data Streaming with Hardware"},{"location":"install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"models/","text":"Behavioral Models The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"About"},{"location":"models/#behavioral-models","text":"The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Behavioral Models"},{"location":"streaming/","text":"Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Data Streaming"},{"location":"streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"support/","text":"Support Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"support/#support","text":"Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"targeting/","text":"HDL Targeting with HDL-Coder High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well. Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat' ); or Linux: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , '/opt/Xilinx/Vivado/2019.1/bin/vivado' ); Please change the tool path if it is different on your system. Checking For Supported Designs To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command: simulink After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page. After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder. This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor. Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so: Moving Bitstreams To Hardware Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms. First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here . Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.","title":"HDL Targeting"},{"location":"targeting/#hdl-targeting-with-hdl-coder","text":"High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"targeting/#getting-started","text":"To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well. Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat' ); or Linux: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , '/opt/Xilinx/Vivado/2019.1/bin/vivado' ); Please change the tool path if it is different on your system.","title":"Getting Started"},{"location":"targeting/#checking-for-supported-designs","text":"To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command: simulink After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page. After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder. This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor. Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:","title":"Checking For Supported Designs"},{"location":"targeting/#moving-bitstreams-to-hardware","text":"Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms. First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here . Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.","title":"Moving Bitstreams To Hardware"},{"location":"_pages/","text":"{% include 'header.tmpl' %} .md-typeset h1, .md-content__button { display: none; } ADI maintains a set of tools to model, interface, and target with ADI high-speed devices within MATLAB and Simulink. These are combined into single Toolbox which contains a set of Board Support Packages (BSP). The list of supported boards is provided below. The following have device-specific implementations in MATLAB and Simulink. If a device has an IIO driver, MATLAB support is possible, but a device-specific MATLAB or Simulink interface may not exist yet. Evaluation Card FPGA Board Streaming Support Targeting Variants and Minimum Supported Release DAQ2 (AD9680/AD9144) ZC706 Yes No ADI (2019a) ZCU102 Yes Yes ADI (2019a) Arria10 SoC Yes No ADI (2019a) DAQ3 (AD9680/AD9152) ZC706 Yes No ADI (2021b) ZCU102 Yes No ADI (2021b) KCU105 Yes No ADI (2021b) Arria10 SoC Yes No ADI (2021b) DualAD9213 Stratix 10 Yes No ADI (2021b) AD9081/AD9082 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9083 ZCU102 Yes No ADI (2021b) AD9988/AD9986 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) AD9209/AD9177 ZCU102 Yes Yes ADI (2020a) VCU118 Yes No ADI (2020a) QuadMxFE (AD9081 x4) VCU118 Yes No ADI (2020a) AD9467 Zedboard Yes No ADI (2018b)","title":"Index"},{"location":"_pages/examples/","text":"{% include 'header.tmpl' %} Examples Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"_pages/examples/#examples","text":"Examples for streaming data are listed within the Toolbox documentation itself. To view run the following with MATLAB: doc adi They can also be viewed on GitHub: Streaming examples","title":"Examples"},{"location":"_pages/install/","text":"{% include 'header.tmpl' %} Installation Dependencies The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation. Simulation Models The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink Data Streaming with Hardware The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122 HDL Generation Support To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform Transceiver Toolbox Install The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page . Add-On Explorer Walkthrough To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Install"},{"location":"_pages/install/#installation","text":"","title":"Installation"},{"location":"_pages/install/#dependencies","text":"The toolbox has different dependencies based on the features required. These are broken down into the base dependencies for running models, data stream and control, and HDL code generation.","title":"Dependencies"},{"location":"_pages/install/#simulation-models","text":"The simulation models for the different components can be used in either MATLAB or Simulink through the MATLAB System block. To run the available models requires the following toolboxes from MathWorks: DSP System Toolbox Signal Processing Toolbox Fixed-Point Designer (Optional) Simulink","title":"Simulation Models"},{"location":"_pages/install/#data-streaming-with-hardware","text":"The base dependencies for the toolbox requires libiio and the libiio MATLAB bindings. There are three options for this install with different required MathWorks Toolboxes: Communications Toolbox Support Package for Xilinx Zynq-Based Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 Communications Toolbox Support Package for Analog Devices ADALM-Pluto Radio Communications Toolbox Signal Processing Toolbox\u2122 DSP System Toolbox\u2122 libiio MATLAB Binding Standalone Installer (R2021b+) Signal Processing Toolbox\u2122","title":"Data Streaming with Hardware"},{"location":"_pages/install/#hdl-generation-support","text":"To leverage HDL-Coder and the reference designs with the toolbox requires the following components: Xilinx Vivado 2019.1 Xilinx SDK 2019.1 Simulink HDL-Coder\u2122 HDL Coder\u2122 Support Package for Xilinx Zynq Platform","title":"HDL Generation Support"},{"location":"_pages/install/#transceiver-toolbox-install","text":"The Transceiver Toolbox itself can be installed either from: MATLAB's Add-On Explorer GitHub Releases page . MATLAB Versions Before installing Transceiver Toolbox check the Release Page to check for the lasted supported of MATLAB. The latest version is the one which is available in Add-on Explorer , since Add-On Explorer does not currently support hosting multiple versions. If you have an older release of MATLAB, download the MLTBX installer from matching release on the Release Page .","title":"Transceiver Toolbox Install"},{"location":"_pages/install/#add-on-explorer-walkthrough","text":"To install the toolbox from within MATLAB using the Add-On Explorer, first launch the Explorer from MATLAB's Home tab: Search for the toolbox: Select Transceiver Toolbox from results: Select add:","title":"Add-On Explorer Walkthrough"},{"location":"_pages/models/","text":"{% include 'header.tmpl' %} Behavioral Models The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Models"},{"location":"_pages/models/#behavioral-models","text":"The toolbox contains behavioral simulation models of different data converters that can be used in MATLAB and Simulink. These are designed to help users understand device limitations and advanced feature sets. As well as to test their algorithms and signal processing against. The currently supported behavioral models are: AD9081 MxFE Quad, 16-Bit, 12GSPS RFDAC and Quad, 12-Bit, 4GSPS RFADC","title":"Behavioral Models"},{"location":"_pages/streaming/","text":"{% include 'header.tmpl' %} Receiving and Sending Data Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages. Connecting and Configuration Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx(); Receiving Data To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data. Sending Data Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA'; DDS Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"Streaming"},{"location":"_pages/streaming/#receiving-and-sending-data","text":"Remote data streaming to and from hardware is made available through system object interfaces , which are unique for each component or platform. The hardware interfacing system objects provide a since class to both configure a given platform and move data back and forth from the device. Command and control of hardware from MATLAB is accomplished by leveraging the IIO drivers built into the target platform's kernel and libiio which provides remote backends to control drivers across different backends. Backends can be Ethernet, serial, or USB based. Below is a diagram of the different components in the stack for an FMComms based systems, but will be nearly identical for all transceiver based systems. Since libiio is cross-platform it can be used from Windows, Linux, or macOS based systems. It is also a lower level library independent of MATLAB, so when moving toward production or untethered systems similar APIs that are used in MATLAB can be used in C,C++,Python, or other languages.","title":"Receiving and Sending Data"},{"location":"_pages/streaming/#connecting-and-configuration","text":"Connecting to hardware is done by setting the uri property of the system object interface. The uri for libiio always has the convention \" < backend >:< address > \", where backend can be ip,usb, or serial. address will be specific to the backend. This is documented in the libiio API . Below is a basic example of setting up an AD9361 receiver using an Ethernet/IP backend where the address of the target system is 192.168.2.1: 1 2 3 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; data = rx(); With the code above, the hardware is not contacted until the operator or step method is called on line 3. Therefore, any properties that are set or defined before line 3 are not applied or updated on the hardware until after line 3. However, after line 3 has completed the object will become locked and certain configuration changes cannot be applied after this point. These will primarily sample rates and buffer sizes. The state of the object follows the flow of the diagram below triggered by line 3 above. graph LR Z[Operator Called] -->A; A[Connect To Board] --> B[Update Properties]; B --> C[Initialize Buffers]; C --> D[Send or Receive Data]; D --> E[Lock Object]; Once the object becomes locked it must be released if the sample rate or buffers need to be modified. This will disconnect from the hardware: rx.release(); % Release object To provide a complete example we can do more advanced configuration like so to demonstrate property changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 rx = adi.AD9081.Rx; rx.uri = 'ip:192.168.2.1'; rx.SamplesPerFrame = 1024; rx.ChannelNCOFrequencies = [1e9,1e9,1e9,1e9]; dataNCO1 = rx(); % Update tunable property rx.ChannelNCOFrequencies = [2e9,2e9,2e9,2e9]; dataNCO2 = rx(); % Update non-tunable property rx.release(); rx.SamplesPerFrame = 4096; dataLargerBuffer = rx();","title":"Connecting and Configuration"},{"location":"_pages/streaming/#receiving-data","text":"To receive or capture data from a given device first you must instantiate that device's interface class. For example on a DAQ2 based system, this would be as follows: rx = adi.DAQ2.Rx; Once instantiated you can configure the number of samples to be captured by setting the property SamplesPerFrame. rx.SamplesPerFrame = 1e6; SamplesPerFrame is the number of samples per channel which will be captured. If your device produces complex data (I and Q) this is the number of complex samples. There will be a limit to the maximum samples which can be collected. By default this is set to 2^20, but it may be possible to make it larger depending on hardware. Once the operator methods are used for a give instantiation, the object will become locked and the SamplesPerFrame property cannot be changed. This is known as a non-tunable property. To actually collect the samples or perform the capture, the operator of the system object should be used or the step method as so: data = rx(); % Operator method data = rx.step(); % Step method Both method calls are equivalent, and the produced matrix data will be of size [SamplesPerFrame x length(EnabledChannels)]. EnabledChannels determines the channels which data will be collected from. EnabledChannels is a [1xN] vector with indexes starting at 1 of the desired channels. If the device transmits or receive complex data, these indexes are for complex channel pairs. For example, the AD9081 can have 16 complex channels from 4 ADCs and setting EnabledChannels as so will capture data from all 16 converters: rx.EnabledChannels = 1:16; You cannot enable individual converters on complex data based devices, and the EnabledChannels property is always sorted so the channel mappings cannot be changed within the produced data.","title":"Receiving Data"},{"location":"_pages/streaming/#sending-data","text":"Transmitting data is very similar to receiving it, a transmitter class needs to be instantiated to send data first. For an AD9081 based device this would be as follows: tx = adi.AD9081.Tx; Unlike the receivers, transmit objects automatically create their internal buffers based on the data passed to them during their operator or step methods. These methods can be called as follows with some data: tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Operator method tx.step(tx_data); % Step method However, once the step or operator method is called the object becomes locked and future passed data vectors must be the same length. As with the receive classes, the size of the passed data must be [SomeFixedSize x EnabledChannels]. EnabledChannels has the same definition as the receive side, except applied to DACs. Unlike the receiver, transmit objects have the ability to utilize cyclic buffers which will continuously transmit a provided vector without gaps forever. To utilize cyclic buffers set the EnableCyclicBuffers property then pass the operator data as follows: tx = adi.AD9081.Tx; tx.EnableCyclicBuffers = true; tx_data = complex(2^15.*randn(1024,1),2^15.*randn(1024,1)); tx(tx_data); % Data will repeat forever Once a vector is passed to the object with EnableCyclicBuffers set to true , the object will not accept future buffers unless first release or cleared. By default the system objects will utilize DMA as the source of data for the DACs, which will use data past from the operator. This can be set manually through the DataSource properties as follows: rx.DataSource = 'DMA';","title":"Sending Data"},{"location":"_pages/streaming/#dds","text":"Instead of providing data for transmission, it is possible to utilize DDSs inside the FPGA to send tones to individual DACs. For specific boards there are two DDS per DAC, which can be used to create complex (one-sided) tones. These DDSs can be used by first setting the DataSource property: rx.DataSource = 'DDS'; Then the scale, frequency, and phase of each DDS can be controlled through three attributes as follows: rx.DDSFrequencies = [1e3,1e3,1e3,1e3;1e4,1e4,1e4,1e4]; % Must be range [0 FS/2] rx.DDSScales = [1,1,1,1;0,0,0,0]; % Must be range [0,1] rx.DDSPhases = [0,90e3,0,90e3,0,0;0,0,0,0]; % Each in millidegrees [0,90000] Each of the above properties must be of size [2x(NumberOfPartDACs)], where each row is the first DDS of a given DAC (column) and the second row is the second DDS of a given DAC (column).","title":"DDS"},{"location":"_pages/support/","text":"{% include 'header.tmpl' %} Support Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"_pages/support/#support","text":"Support is provided online through the EngineerZone forums. If you have questions related to the hardware itself outside of this BSP, contact your local FAE or ask on the forums. Question regarding specific aspect of the BSP should be asked in the following places: Software Interface Tools for questions on the BSP itself Linux Software Drivers for libiio and iio driver questions","title":"Support"},{"location":"_pages/targeting/","text":"HDL Targeting with HDL-Coder High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support Recommended Review Getting started with Zynq Getting Started To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well. Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat' ); or Linux: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , '/opt/Xilinx/Vivado/2019.1/bin/vivado' ); Please change the tool path if it is different on your system. Checking For Supported Designs To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command: simulink After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page. After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder. This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor. Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so: Moving Bitstreams To Hardware Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms. First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here . Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.","title":"HDL Targeting with HDL-Coder"},{"location":"_pages/targeting/#hdl-targeting-with-hdl-coder","text":"High-Speed Converter Toolbox supports the IP Core generation flow from MathWorks which allows for automated integration of DSP into HDL reference designs from Analog Devices. This workflow will take Simulink subsystems, run HDL-Coder to generate source Verilog, and then integrate that into a larger reference design. The figure below is a simplified block diagram of a SoC (Fabric+ARM) device, where specialized IP are inserted into the receive and transmit datapaths. This is supported on specific FPGA families and high-speed based reference designs. This support is based on the Zynq HDL-Coder and support","title":"HDL Targeting with HDL-Coder"},{"location":"_pages/targeting/#recommended-review","text":"Getting started with Zynq","title":"Recommended Review"},{"location":"_pages/targeting/#getting-started","text":"To perform targeting will require FPGA vendor tools for the FPGA system. For Xilinx this will be Vivado and the toolbox will require specific versions for each release. For the current release this is Vivado 2019.1. Using other versions are not supported. To build the necessary BOOT.BIN files will require the Xilinx SDK as well. Once you have the installed the necessary 3rd party tools MATLAB needs to be told where they are installed by use of the hdlsetuptoolpath command. For Windows the following MATLAB command can be used: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , 'C:\\Xilinx\\Vivado\\2019.1\\bin\\vivado.bat' ); or Linux: hdlsetuptoolpath ( 'ToolName' , 'Xilinx Vivado' , 'ToolPath' , '/opt/Xilinx/Vivado/2019.1/bin/vivado' ); Please change the tool path if it is different on your system.","title":"Getting Started"},{"location":"_pages/targeting/#checking-for-supported-designs","text":"To verify that the ADI reference designs are available to HDL Workflow Advisor a Simulink model needs to be opened. To do so launch Simulink with the following command: simulink After it launches open a \"Blank DUT\" model from the \"HDL Coder\" dropdown of the Simulink Start Page. After the model opens, click on the green subsystem to select it. Then open the \"Apps\" tap, open the apps menu and scroll down to HDL-Coder. This will open the HDL-Coder menu, from here the Workflow Advisor is selectable. Click on it to launch the advisor. Once launch go to Step 1.1 on the left side column. Then on the right side of the window select \"IP Core Generation\" for \"Target workflow\". Then the ADI reference designs should be available in the \"Target platform\" menu as so:","title":"Checking For Supported Designs"},{"location":"_pages/targeting/#moving-bitstreams-to-hardware","text":"Unlike support packages provided by MathWorks, the update process for the bitstreams requires the creation of a BOOT.BIN file which will be compatible with the ADI SD card. BOOT.BIN's contain the bitstream (system_top.bit), FSBL, and u-boot for ADI platforms. First, make sure you have a valid SD card for your platform with the necessary device tree and kernel image selected. Follow this process here . Once your SD card is ready, in step 4.3 \"Build FPGA Bitstream\" of HDL Workflow Advisor select a custom Tcl file for synthesis build. Utilize this adi_build.tcl file for Linux or this adi_build_win.tcl file for Windows located within the BSP as your custom tcl file. Once the bitstream is built it will generate the BOOT.BIN necessary for booting your system. Place the generated BOOT.BIN in the root of your ADI SD card's BOOT partition.","title":"Moving Bitstreams To Hardware"},{"location":"hdlrefdesigns/ad9081/","text":"ad9081 Reference Design Integration This page outlines the HDL reference design integration for the ad9081 reference design for the Analog Devices AD9081 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_mxfe_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_mxfe_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_mxfe_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_mxfe_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_mxfe_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_mxfe_cpack/fifo_wr_data_3 16 RX DATA-OUT IP Data 4 OUT util_mxfe_cpack/fifo_wr_data_4 16 RX DATA-OUT IP Data 5 OUT util_mxfe_cpack/fifo_wr_data_5 16 RX DATA-OUT IP Data 6 OUT util_mxfe_cpack/fifo_wr_data_6 16 RX DATA-OUT IP Data 7 OUT util_mxfe_cpack/fifo_wr_data_7 16 RX DATA-IN AD9081 ADC Data 0 IN rx_mxfe_tpl_core/adc_data_0 16 RX DATA-IN AD9081 ADC Data 1 IN rx_mxfe_tpl_core/adc_data_1 16 RX DATA-IN AD9081 ADC Data 2 IN rx_mxfe_tpl_core/adc_data_2 16 RX DATA-IN AD9081 ADC Data 3 IN rx_mxfe_tpl_core/adc_data_3 16 RX DATA-IN AD9081 ADC Data 4 IN rx_mxfe_tpl_core/adc_data_4 16 RX DATA-IN AD9081 ADC Data 5 IN rx_mxfe_tpl_core/adc_data_5 16 RX DATA-IN AD9081 ADC Data 6 IN rx_mxfe_tpl_core/adc_data_6 16 RX DATA-IN AD9081 ADC Data 7 IN rx_mxfe_tpl_core/adc_data_7 16 RX VALID-IN IP Valid Tx Data IN util_mxfe_upack/fifo_rd_valid 1 TX DATA-OUT AD9081 DAC Data 0 OUT tx_mxfe_tpl_core/dac_data_0 16 TX DATA-OUT AD9081 DAC Data 1 OUT tx_mxfe_tpl_core/dac_data_1 16 TX DATA-OUT AD9081 DAC Data 2 OUT tx_mxfe_tpl_core/dac_data_2 16 TX DATA-OUT AD9081 DAC Data 3 OUT tx_mxfe_tpl_core/dac_data_3 16 TX DATA-OUT AD9081 DAC Data 4 OUT tx_mxfe_tpl_core/dac_data_4 16 TX DATA-OUT AD9081 DAC Data 5 OUT tx_mxfe_tpl_core/dac_data_5 16 TX DATA-OUT AD9081 DAC Data 6 OUT tx_mxfe_tpl_core/dac_data_6 16 TX DATA-OUT AD9081 DAC Data 7 OUT tx_mxfe_tpl_core/dac_data_7 16 TX DATA-IN IP Data 0 IN util_mxfe_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_mxfe_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_mxfe_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_mxfe_upack/fifo_rd_data_3 16 TX DATA-IN IP Data 4 IN util_mxfe_upack/fifo_rd_data_4 16 TX DATA-IN IP Data 5 IN util_mxfe_upack/fifo_rd_data_5 16 TX DATA-IN IP Data 6 IN util_mxfe_upack/fifo_rd_data_6 16 TX DATA-IN IP Data 7 IN util_mxfe_upack/fifo_rd_data_7 16 TX","title":"ad9081"},{"location":"hdlrefdesigns/ad9081/#ad9081-reference-design-integration","text":"This page outlines the HDL reference design integration for the ad9081 reference design for the Analog Devices AD9081 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"ad9081 Reference Design Integration"},{"location":"hdlrefdesigns/ad9081/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/ad9081/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_mxfe_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_mxfe_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_mxfe_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_mxfe_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_mxfe_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_mxfe_cpack/fifo_wr_data_3 16 RX DATA-OUT IP Data 4 OUT util_mxfe_cpack/fifo_wr_data_4 16 RX DATA-OUT IP Data 5 OUT util_mxfe_cpack/fifo_wr_data_5 16 RX DATA-OUT IP Data 6 OUT util_mxfe_cpack/fifo_wr_data_6 16 RX DATA-OUT IP Data 7 OUT util_mxfe_cpack/fifo_wr_data_7 16 RX DATA-IN AD9081 ADC Data 0 IN rx_mxfe_tpl_core/adc_data_0 16 RX DATA-IN AD9081 ADC Data 1 IN rx_mxfe_tpl_core/adc_data_1 16 RX DATA-IN AD9081 ADC Data 2 IN rx_mxfe_tpl_core/adc_data_2 16 RX DATA-IN AD9081 ADC Data 3 IN rx_mxfe_tpl_core/adc_data_3 16 RX DATA-IN AD9081 ADC Data 4 IN rx_mxfe_tpl_core/adc_data_4 16 RX DATA-IN AD9081 ADC Data 5 IN rx_mxfe_tpl_core/adc_data_5 16 RX DATA-IN AD9081 ADC Data 6 IN rx_mxfe_tpl_core/adc_data_6 16 RX DATA-IN AD9081 ADC Data 7 IN rx_mxfe_tpl_core/adc_data_7 16 RX VALID-IN IP Valid Tx Data IN util_mxfe_upack/fifo_rd_valid 1 TX DATA-OUT AD9081 DAC Data 0 OUT tx_mxfe_tpl_core/dac_data_0 16 TX DATA-OUT AD9081 DAC Data 1 OUT tx_mxfe_tpl_core/dac_data_1 16 TX DATA-OUT AD9081 DAC Data 2 OUT tx_mxfe_tpl_core/dac_data_2 16 TX DATA-OUT AD9081 DAC Data 3 OUT tx_mxfe_tpl_core/dac_data_3 16 TX DATA-OUT AD9081 DAC Data 4 OUT tx_mxfe_tpl_core/dac_data_4 16 TX DATA-OUT AD9081 DAC Data 5 OUT tx_mxfe_tpl_core/dac_data_5 16 TX DATA-OUT AD9081 DAC Data 6 OUT tx_mxfe_tpl_core/dac_data_6 16 TX DATA-OUT AD9081 DAC Data 7 OUT tx_mxfe_tpl_core/dac_data_7 16 TX DATA-IN IP Data 0 IN util_mxfe_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_mxfe_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_mxfe_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_mxfe_upack/fifo_rd_data_3 16 TX DATA-IN IP Data 4 IN util_mxfe_upack/fifo_rd_data_4 16 TX DATA-IN IP Data 5 IN util_mxfe_upack/fifo_rd_data_5 16 TX DATA-IN IP Data 6 IN util_mxfe_upack/fifo_rd_data_6 16 TX DATA-IN IP Data 7 IN util_mxfe_upack/fifo_rd_data_7 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9002/","text":"adrv9002 Reference Design Integration This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"adrv9002 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9002/#adrv9002-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9002 reference design for the Analog Devices ADRV9002 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9002 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9002/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9002/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adc_1_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_adrv9001/adc_1_valid_i0 1 RX DATA-OUT IP Data 0 OUT util_adc_1_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adc_1_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adc_1_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adc_1_pack/fifo_wr_data_3 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_i0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_i1 16 RX DATA-IN ADRV9002 ADC Data Q0 axi_adrv9001/adc_1_data_q0 16 RX DATA-IN ADRV9002 ADC Data I0 axi_adrv9001/adc_1_data_q1 16 RX VALID-IN IP Valid Tx Data IN util_dac_1_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_dac_1_upack/fifo_rd_en 1 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_i0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_i1 16 TX DATA-OUT ADRV9002 DAC Data Q0 axi_adrv9001/dac_1_data_q0 16 TX DATA-OUT ADRV9002 DAC Data I0 axi_adrv9001/dac_1_data_q1 16 TX DATA-IN IP Data 0 IN util_dac_1_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_dac_1_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_dac_1_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_dac_1_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9009/","text":"adrv9009 Reference Design Integration This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"adrv9009 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9009/#adrv9009-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9009 reference design for the Analog Devices ADRV9009 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"adrv9009 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9009/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9009/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_adrv9009_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_adrv9009_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_adrv9009_rx_cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_adrv9009_rx_cpack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_adrv9009_rx_cpack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_adrv9009_rx_cpack/fifo_wr_data_3 16 RX DATA-IN ADRV9009 ADC Data Q0 rx_adrv9009_tpl_core/adc_data_0 16 RX DATA-IN ADRV9009 ADC Data I0 rx_adrv9009_tpl_core/adc_data_1 16 RX DATA-IN ADRV9009 ADC Data Q1 rx_adrv9009_tpl_core/adc_data_2 16 RX DATA-IN ADRV9009 ADC Data I1 rx_adrv9009_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_adrv9009_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_adrv9009_tx_upack/fifo_rd_en 1 TX DATA-OUT ADRV9009 DAC Data Q0 tx_adrv9009_tpl_core/dac_data_0 16 TX DATA-OUT ADRV9009 DAC Data I0 tx_adrv9009_tpl_core/dac_data_1 16 TX DATA-OUT ADRV9009 DAC Data Q1 tx_adrv9009_tpl_core/dac_data_2 16 TX DATA-OUT ADRV9009 DAC Data I1 tx_adrv9009_tpl_core/dac_data_3 16 TX DATA-IN IP Data 0 IN util_adrv9009_tx_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_adrv9009_tx_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_adrv9009_tx_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_adrv9009_tx_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9361z7035/","text":"adrv9361z7035 Reference Design Integration This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9361z7035 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9361z7035/#adrv9361z7035-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9361z7035 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS CCFMC_LVDS CCPACKRF_LVDS Supported design variants: RX TX RX & TX","title":"adrv9361z7035 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9361z7035/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9361z7035/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9364z7020/","text":"adrv9364z7020 Reference Design Integration This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"adrv9364z7020 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9364z7020/#adrv9364z7020-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9364z7020 reference design for the Analog Devices AD9364 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: CCBOB_CMOS CCBOB_LVDS CCBOX_LVDS Supported design variants: RX TX RX & TX","title":"adrv9364z7020 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9364z7020/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9364z7020/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9364 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9364 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9364 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9364 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9364 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9364 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9364 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9364 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/adrv9371/","text":"adrv9371 Reference Design Integration This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"adrv9371 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9371/#adrv9371-reference-design-integration","text":"This page outlines the HDL reference design integration for the adrv9371 reference design for the Analog Devices AD9371 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZC706 ZCU102 Supported design variants: RX TX","title":"adrv9371 Reference Design Integration"},{"location":"hdlrefdesigns/adrv9371/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/adrv9371/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9371_rx_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN rx_ad9371_tpl_core/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9371 ADC Data Q0 rx_ad9371_tpl_core/adc_data_0 16 RX DATA-IN AD9371 ADC Data I0 rx_ad9371_tpl_core/adc_data_1 16 RX DATA-IN AD9371 ADC Data Q1 rx_ad9371_tpl_core/adc_data_2 16 RX DATA-IN AD9371 ADC Data I1 rx_ad9371_tpl_core/adc_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9371_tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT util_ad9371_tx_upack/fifo_rd_en 1 TX DATA-OUT AD9371 DAC Data Q0 tx_ad9371_tpl_core/dac_data_0 32 TX DATA-OUT AD9371 DAC Data I0 tx_ad9371_tpl_core/dac_data_1 32 TX DATA-OUT AD9371 DAC Data Q1 tx_ad9371_tpl_core/dac_data_2 32 TX DATA-OUT AD9371 DAC Data I1 tx_ad9371_tpl_core/dac_data_3 32 TX DATA-IN IP Data 0 IN util_ad9371_tx_upack/fifo_rd_data_0 32 TX DATA-IN IP Data 1 IN util_ad9371_tx_upack/fifo_rd_data_1 32 TX DATA-IN IP Data 2 IN util_ad9371_tx_upack/fifo_rd_data_2 32 TX DATA-IN IP Data 3 IN util_ad9371_tx_upack/fifo_rd_data_3 32 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/daq2/","text":"daq2 Reference Design Integration This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices DAQ2 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9680_tpl/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT axi_ad9680_cpack/fifo_wr_data_0 64 RX DATA-OUT IP Data 1 OUT axi_ad9680_cpack/fifo_wr_data_1 64 RX DATA-IN DAQ2 ADC Data 0 IN axi_ad9680_tpl/adc_data_0 64 RX DATA-IN DAQ2 ADC Data 1 IN axi_ad9680_tpl/adc_data_1 64 RX VALID-IN IP Valid Tx Data IN axi_ad9144_upack/fifo_rd_valid 1 TX DATA-OUT DAQ2 DAC Data 0 OUT axi_ad9144_tpl/dac_data_0 64 TX DATA-OUT DAQ2 DAC Data 1 OUT axi_ad9144_tpl/dac_data_1 64 TX DATA-IN IP Data 0 IN axi_ad9144_upack/fifo_rd_data_0 64 TX DATA-IN IP Data 1 IN axi_ad9144_upack/fifo_rd_data_1 64 TX","title":"daq2"},{"location":"hdlrefdesigns/daq2/#daq2-reference-design-integration","text":"This page outlines the HDL reference design integration for the daq2 reference design for the Analog Devices DAQ2 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZCU102 Supported design variants: RX TX RX & TX","title":"daq2 Reference Design Integration"},{"location":"hdlrefdesigns/daq2/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/daq2/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT axi_ad9680_cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9680_tpl/adc_valid_0 1 RX DATA-OUT IP Data 0 OUT axi_ad9680_cpack/fifo_wr_data_0 64 RX DATA-OUT IP Data 1 OUT axi_ad9680_cpack/fifo_wr_data_1 64 RX DATA-IN DAQ2 ADC Data 0 IN axi_ad9680_tpl/adc_data_0 64 RX DATA-IN DAQ2 ADC Data 1 IN axi_ad9680_tpl/adc_data_1 64 RX VALID-IN IP Valid Tx Data IN axi_ad9144_upack/fifo_rd_valid 1 TX DATA-OUT DAQ2 DAC Data 0 OUT axi_ad9144_tpl/dac_data_0 64 TX DATA-OUT DAQ2 DAC Data 1 OUT axi_ad9144_tpl/dac_data_1 64 TX DATA-IN IP Data 0 IN axi_ad9144_upack/fifo_rd_data_0 64 TX DATA-IN IP Data 1 IN axi_ad9144_upack/fifo_rd_data_1 64 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/fmcomms2/","text":"fmcomms2 Reference Design Integration This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"fmcomms2 Reference Design Integration"},{"location":"hdlrefdesigns/fmcomms2/#fmcomms2-reference-design-integration","text":"This page outlines the HDL reference design integration for the fmcomms2 reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: ZED ZC706 ZC702 Supported design variants: RX TX RX & TX","title":"fmcomms2 Reference Design Integration"},{"location":"hdlrefdesigns/fmcomms2/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/fmcomms2/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT util_ad9361_adc_pack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN util_ad9361_adc_fifo/dout_valid_0 1 RX DATA-OUT IP Data 0 OUT util_ad9361_adc_pack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT util_ad9361_adc_pack/fifo_wr_data_1 16 RX DATA-OUT IP Data 2 OUT util_ad9361_adc_pack/fifo_wr_data_2 16 RX DATA-OUT IP Data 3 OUT util_ad9361_adc_pack/fifo_wr_data_3 16 RX DATA-IN AD9361 ADC Data Q0 util_ad9361_adc_fifo/dout_data_0 16 RX DATA-IN AD9361 ADC Data I0 util_ad9361_adc_fifo/dout_data_1 16 RX DATA-IN AD9361 ADC Data Q1 util_ad9361_adc_fifo/dout_data_2 16 RX DATA-IN AD9361 ADC Data I1 util_ad9361_adc_fifo/dout_data_3 16 RX VALID-IN IP Valid Tx Data IN util_ad9361_dac_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT axi_ad9361_dac_fifo/din_valid_in_0 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361_dac_fifo/din_data_0 16 TX DATA-OUT AD9361 DAC Data I0 axi_ad9361_dac_fifo/din_data_1 16 TX DATA-OUT AD9361 DAC Data Q1 axi_ad9361_dac_fifo/din_data_2 16 TX DATA-OUT AD9361 DAC Data I1 axi_ad9361_dac_fifo/din_data_3 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX DATA-IN IP Data 2 IN util_ad9361_dac_upack/fifo_rd_data_2 16 TX DATA-IN IP Data 3 IN util_ad9361_dac_upack/fifo_rd_data_3 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"hdlrefdesigns/pluto/","text":"pluto Reference Design Integration This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX Reference Design HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above. HDL Worflow Advisor Port Mappings When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"pluto Reference Design Integration"},{"location":"hdlrefdesigns/pluto/#pluto-reference-design-integration","text":"This page outlines the HDL reference design integration for the pluto reference design for the Analog Devices AD9361 component. The IP-Core Generation follow is available on the based on the following base HDL reference design for the following board and design variants: Base reference design documentation Supported FPGA carriers: Supported design variants: RX TX","title":"pluto Reference Design Integration"},{"location":"hdlrefdesigns/pluto/#reference-design","text":"HDL Reference Design with Custom IP from HDL-Coder. Click on sub-blocks for more documentation. The IP-Core generation flow will integrate IP generated from Simulink subsystem into an ADI authored reference design. Depending on the FPGA carrier and FMC card or SoM, this will support different IP locations based on the diagram above.","title":"Reference Design"},{"location":"hdlrefdesigns/pluto/#hdl-worflow-advisor-port-mappings","text":"When using the HDL Worflow Advisor, the following port mappings are used to connect the reference design to the HDL-Coder generated IP-Core: Type Target Platform Interface (MATLAB) Reference Design Connection (Vivado) Width Reference Design Variant VALID-OUT IP Data Valid OUT cpack/fifo_wr_en 1 RX VALID-IN IP Valid Rx Data IN axi_ad9361/adc_valid_i0 1 RX DATA-OUT IP Data 0 OUT cpack/fifo_wr_data_0 16 RX DATA-OUT IP Data 1 OUT cpack/fifo_wr_data_1 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_i0 16 RX DATA-IN AD9361 ADC Data Q0 axi_ad9361/adc_data_q0 16 RX VALID-IN IP Valid Tx Data IN tx_upack/fifo_rd_valid 1 TX VALID-OUT IP Load Tx Data OUT logic_or/Op1 1 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_i0 16 TX DATA-OUT AD9361 DAC Data Q0 axi_ad9361/dac_data_q0 16 TX DATA-IN IP Data 0 IN util_ad9361_dac_upack/fifo_rd_data_0 16 TX DATA-IN IP Data 1 IN util_ad9361_dac_upack/fifo_rd_data_1 16 TX","title":"HDL Worflow Advisor Port Mappings"},{"location":"models/ad9081/adc.tex/","text":"AD9081 ADC and ADC Mux The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact. Top-Level Control There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0 . SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used. help adi . sim . AD9081 . Rx . SampleRate SampleRate Sample Rate of ADCs Scalar in Hz. Currently this is fixed since NSD will change with this number, which would make the model invalid Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system. help adi . sim . AD9081 . Rx . Crossbar4x4Mux0 Crossbar4x4Mux0 Crossbar 4x4 Mux0 Array of input and output mapping. Index is the output and the value is the selected input Example Configuration Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only. rx = adi . sim . AD9081 . Rx ; rx . SampleRate = 4e9 ; rx . Crossbar4x4Mux0 = [ 1 , 1 , 3 , 4 ]; % Pass noise through model at 10 % and 1 % fullscale noiseVolts1 = 1.4 / 2 * 0.1 * randn ( 1000 , 1 ); noiseVolts2 = 1.4 / 2 * 0.01 * randn ( 1000 , 1 ); [ o1 , o2 , ~ , ~ , o3 , o4 ] = rx ( noiseVolts1 , noiseVolts2 , noiseVolts1 , noiseVolts1 ); outs = [ o1 , o2 , o3 , o4 ]; fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 1 ), outs (:, 2 ))) Mapped values identical 1 fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 3 ), outs (:, 4 ))) Mapped values identical 0","title":"ADC"},{"location":"models/ad9081/adc.tex/#ad9081-adc-and-adc-mux","text":"The pipelined ADC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to be similar to the noise spectral density (NSD) of the converters. Note that since physical hardware does not exist these are estimated values and will likely change. There will be other distortions introduce by physical hardware as well, relating to front-end matches, internal chip structures, baluns, and gains stages among others. The ADC model should be considered similar but not exact.","title":"AD9081 ADC and ADC Mux"},{"location":"models/ad9081/adc.tex/#top-level-control","text":"There are two control properties related to ADC control: SampleRate and Crossbar4x4Mux0 . SampleRate is the data rate of the converters themselves. Therefore, the output datarate of the model will be this SampleRate divided by the different decimations used. help adi . sim . AD9081 . Rx . SampleRate SampleRate Sample Rate of ADCs Scalar in Hz. Currently this is fixed since NSD will change with this number, which would make the model invalid Crossbar4x4Mux0 is a full crossbar mux connecting the ADCs to the rest of the system. help adi . sim . AD9081 . Rx . Crossbar4x4Mux0 Crossbar4x4Mux0 Crossbar 4x4 Mux0 Array of input and output mapping. Index is the output and the value is the selected input","title":"Top-Level Control"},{"location":"models/ad9081/adc.tex/#example-configuration","text":"Here is a basic example were we want to map ADC0, ADC1, and ADC2 out only. rx = adi . sim . AD9081 . Rx ; rx . SampleRate = 4e9 ; rx . Crossbar4x4Mux0 = [ 1 , 1 , 3 , 4 ]; % Pass noise through model at 10 % and 1 % fullscale noiseVolts1 = 1.4 / 2 * 0.1 * randn ( 1000 , 1 ); noiseVolts2 = 1.4 / 2 * 0.01 * randn ( 1000 , 1 ); [ o1 , o2 , ~ , ~ , o3 , o4 ] = rx ( noiseVolts1 , noiseVolts2 , noiseVolts1 , noiseVolts1 ); outs = [ o1 , o2 , o3 , o4 ]; fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 1 ), outs (:, 2 ))) Mapped values identical 1 fprintf ( 'Mapped values identical %d \\n ' , isequal ( outs (:, 3 ), outs (:, 4 ))) Mapped values identical 0","title":"Example Configuration"},{"location":"models/ad9081/dac.tex/","text":"AD9081 DAC The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB. Top-Level Control There are one control properties related to the DACs: SampleRate . SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used. help adi . sim . AD9081 . Tx . SampleRate SampleRate Sample Rate of DACs Scalar in Hz InverseSincGainAdjustDB Inverse Gain Adjust DB Add gain to the output signal filter. Gain is in dB and can only be >=0 but <=8.7040. This will be internally quantized based on the 8-bit allowed values with steps of 0.034dB.","title":"DAC"},{"location":"models/ad9081/dac.tex/#ad9081-dac","text":"The DAC models are simplified behavioral implementations that are based on the currently estimated specifications of the data converters. They are designed to match the noise spectral density (NSD). Note that since physical hardware does not exist these are estimated values and will likely change by a few dB.","title":"AD9081 DAC"},{"location":"models/ad9081/dac.tex/#top-level-control","text":"There are one control properties related to the DACs: SampleRate . SampleRate is the data rate of the converters themselves. Therefore, the input datarate of the model will be this SampleRate divided by the different interpolations used. help adi . sim . AD9081 . Tx . SampleRate SampleRate Sample Rate of DACs Scalar in Hz InverseSincGainAdjustDB Inverse Gain Adjust DB Add gain to the output signal filter. Gain is in dB and can only be >=0 but <=8.7040. This will be internally quantized based on the 8-bit allowed values with steps of 0.034dB.","title":"Top-Level Control"},{"location":"models/ad9081/ddc2.tex/","text":"AD9081 Digital Down Converters The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed. Top-Level Control The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively. help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Rx . ChannelizerPathDecimation ChannelizerPathDecimation Channelizer Path Decimation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24] Muxing The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings. help adi . sim . AD9081 . Rx . Crossbar4x8Mux2 Crossbar4x8Mux2 Crossbar 4x8 Mux2 Array of input and output mapping. Index is the output and the value is the selected input (values should not exceed 4) NCO Mixer Enable and Modes If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. help adi . sim . AD9081 . Rx . CDDCNCOEnable CDDCNCOEnable CDDC NCO Enable 1x4 Array of booleans to enable NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOEnable FDDCNCOEnable FDDC NCO Enable 1x4 Array of booleans to enable NCOs in channelizer path NCO Frequency and Phase Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies , CDDCNCOPhases , and FDDCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage. help adi . sim . AD9081 . Rx . CDDCNCOFrequencies CDDCNCOFrequencies CDDC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOFrequencies FDDCNCOFrequencies FDDC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path Example Configuration The example below take a single input tone and shifts it into separate channels using the CDDC NCOs. rx = adi . sim . AD9081 . Rx ; % Enable 3 NCOs to shift single into different bands rx . MainDataPathDecimation = 4 ; rx . CDDCNCOEnable = [ true , true , true , false ]; rx . CDDCNCOFrequencies = [ 5e7 , - 3e7 , 1e8 , 0 ]; rx . Crossbar4x8Mux2 = [ 1 , 2 , 1 , 2 , 3 , 4 , 3 , 4 ]; % Create sinewave input sw = dsp . SineWave ; sw . Amplitude = 1.4 * 0.5 ; sw . Frequency = 100e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); [ o1 , o2 , ~ , ~ , o5 , o6 ] = rx ( data , data , data , data ); outputCodes = [ o1 , o2 , o5 , o6 ]; % Plot spectrum Nfft = length ( outputCodes ); fullscale = 2 ^ 15 ; fs = rx . SampleRate / 4 ; win = kaiser ( Nfft , 100 ); win = win / sum ( win ); win = win * Nfft ; outputCodes = double ( outputCodes ) .* win ; spec = fft ( outputCodes ) / Nfft ; spec_db = 20 * log10 ( abs ( spec ) / fullscale + 10 ^- 20 ); df = fs / Nfft ; freqRangeRx = ( - fs / 2 : df : fs / 2 - df ) . '; plot ( freqRangeRx , fftshift ( spec_db )); legend ( 'CDDC0' , 'CDDC1' , 'CDDC2' , 'CDDC3' ) xlabel ( 'Frequency (Hz)' ); ylabel ( 'Magnitude (dBFS)' );","title":"DDC"},{"location":"models/ad9081/ddc2.tex/#ad9081-digital-down-converters","text":"The AD9081 has two sets of digital down converters (DDC), the coarse (CDDC) and fine (FDDC), both following the ADC and PFILTs. These are used to both decimate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDDCs and FDDC are almost identical except for their available decimations, allowable rates, and count. There are two CDDCs per ADC pair and four FDDCs per ADC pair. In the data pipeline, data from the ADCs will be passed through the CDDCs, or bypass the CDDCs, then routed through a mux into the FDDCs, which can also be bypassed.","title":"AD9081 Digital Down Converters"},{"location":"models/ad9081/ddc2.tex/#top-level-control","text":"The CDDC and FDDC decimations are controlled by MainDataPathDecimation and ChannelizerPathDecimation respectively. help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Rx . ChannelizerPathDecimation ChannelizerPathDecimation Channelizer Path Decimation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24]","title":"Top-Level Control"},{"location":"models/ad9081/ddc2.tex/#muxing","text":"The CDDC pairs share a common full crossbar to the four downstream FDDCs connected to them. This is represented by a single crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar4x8Mux2 and will constrain all the mappings. help adi . sim . AD9081 . Rx . Crossbar4x8Mux2 Crossbar4x8Mux2 Crossbar 4x8 Mux2 Array of input and output mapping. Index is the output and the value is the selected input (values should not exceed 4)","title":"Muxing"},{"location":"models/ad9081/ddc2.tex/#nco-mixer-enable-and-modes","text":"If the NCOs need to be used they must be individually enabled through the CDDCNCOEnable and FDDCNCOEnable properties, which are both arrays of booleans. help adi . sim . AD9081 . Rx . CDDCNCOEnable CDDCNCOEnable CDDC NCO Enable 1x4 Array of booleans to enable NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOEnable FDDCNCOEnable FDDC NCO Enable 1x4 Array of booleans to enable NCOs in channelizer path","title":"NCO Mixer Enable and Modes"},{"location":"models/ad9081/ddc2.tex/#nco-frequency-and-phase","text":"Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDDCNCOFrequencies, FDDCNCOFrequencies , CDDCNCOPhases , and FDDCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. Note that both the frequency and phase values are internally quantized to 48-bits based on the effective range of the NCO based on the sample rate into a given stage. help adi . sim . AD9081 . Rx . CDDCNCOFrequencies CDDCNCOFrequencies CDDC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Rx . FDDCNCOFrequencies FDDCNCOFrequencies FDDC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"NCO Frequency and Phase"},{"location":"models/ad9081/ddc2.tex/#example-configuration","text":"The example below take a single input tone and shifts it into separate channels using the CDDC NCOs. rx = adi . sim . AD9081 . Rx ; % Enable 3 NCOs to shift single into different bands rx . MainDataPathDecimation = 4 ; rx . CDDCNCOEnable = [ true , true , true , false ]; rx . CDDCNCOFrequencies = [ 5e7 , - 3e7 , 1e8 , 0 ]; rx . Crossbar4x8Mux2 = [ 1 , 2 , 1 , 2 , 3 , 4 , 3 , 4 ]; % Create sinewave input sw = dsp . SineWave ; sw . Amplitude = 1.4 * 0.5 ; sw . Frequency = 100e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); [ o1 , o2 , ~ , ~ , o5 , o6 ] = rx ( data , data , data , data ); outputCodes = [ o1 , o2 , o5 , o6 ]; % Plot spectrum Nfft = length ( outputCodes ); fullscale = 2 ^ 15 ; fs = rx . SampleRate / 4 ; win = kaiser ( Nfft , 100 ); win = win / sum ( win ); win = win * Nfft ; outputCodes = double ( outputCodes ) .* win ; spec = fft ( outputCodes ) / Nfft ; spec_db = 20 * log10 ( abs ( spec ) / fullscale + 10 ^- 20 ); df = fs / Nfft ; freqRangeRx = ( - fs / 2 : df : fs / 2 - df ) . '; plot ( freqRangeRx , fftshift ( spec_db )); legend ( 'CDDC0' , 'CDDC1' , 'CDDC2' , 'CDDC3' ) xlabel ( 'Frequency (Hz)' ); ylabel ( 'Magnitude (dBFS)' );","title":"Example Configuration"},{"location":"models/ad9081/duc.tex/","text":"AD9081 Digital Up Converters The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed. Top-Level Control The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively. help adi . sim . AD9081 . Tx . MainDataPathInterpolation MainDataPathInterpolation Main Data Path Interpolation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Tx . ChannelizerPathInterpolation ChannelizerPathInterpolation Channelizer Path Interpolation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24] Muxing The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings. help adi . sim . AD9081 . Tx . Crossbar8x8Mux Crossbar8x8Mux Crossbar 8x8 Mux Logical 4x8 array of for MainDataPath input summers. Each row corresponds to each summmer [1-4] and each column corresponds to an input Channelizer path 1-8]. Set indexes to true to enable a given path to be added into summer's output. The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0->FDUC3 and FDUC4->FDUC7). This is controlled by the columns of Crossbar8x8Mux , where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and FDUC4,FDUC5 to CDDC2: tx = adi . sim . AD9081 . Tx ; tx . Crossbar8x8Mux = [ ... 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC0 -> CDUC0 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC1 -> CDUC1 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ; ... FDUC2 -> CDUC2 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ]; % FDUC3 -> CDUC3 NCO Frequency and Phase Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies , CDUCNCOPhases , and FDUCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. help adi . sim . AD9081 . Tx . CDUCNCOFrequencies CDUCNCOFrequencies CDUC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Tx . FDUCNCOFrequencies FDUCNCOFrequencies FDUC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"DUC"},{"location":"models/ad9081/duc.tex/#ad9081-digital-up-converters","text":"The AD9081 has two sets of digital up converters (DUC), the coarse (CDUC) and fine (FDUC). These are used to both interpolate and move signals using the NCOs. They also can be used to phase shift and apply gain to the input signal. The CDUCs and FDUC are almost identical except for their available interpolations, allowable rates, and count. There are two CDUCs per DAC pair and four FDUCs per DAC pair. In the data pipeline, data from the input will be passed through the FDUCs, or bypass the FDUCs, then routed through a mux into the CDUCs, which can also be bypassed.","title":"AD9081 Digital Up Converters"},{"location":"models/ad9081/duc.tex/#top-level-control","text":"The CDUC and FDUC interpolations are controlled by MainDataPathInterpolation and ChannelizerPathInterpolation respectively. help adi . sim . AD9081 . Tx . MainDataPathInterpolation MainDataPathInterpolation Main Data Path Interpolation Specify the decimation in the main data path which can be [1,2,3,4,6] help adi . sim . AD9081 . Tx . ChannelizerPathInterpolation ChannelizerPathInterpolation Channelizer Path Interpolation Specify the decimation in the channelizer path which can be [1,2,3,4,6,8,12,16,24]","title":"Top-Level Control"},{"location":"models/ad9081/duc.tex/#muxing","text":"The FDUC quads share a common full crossbar to the pairs of upstream CDUCs connected to them. This is represented by a single summing crossbar that limits routes to the halves of AD9081. This crossbar or mux is controlled by the Crossbar8x8Mux and will constrain all the mappings. help adi . sim . AD9081 . Tx . Crossbar8x8Mux Crossbar8x8Mux Crossbar 8x8 Mux Logical 4x8 array of for MainDataPath input summers. Each row corresponds to each summmer [1-4] and each column corresponds to an input Channelizer path 1-8]. Set indexes to true to enable a given path to be added into summer's output. The 8x8 summing crossbar can sum any channels within the FDUC quads (FDUC0->FDUC3 and FDUC4->FDUC7). This is controlled by the columns of Crossbar8x8Mux , where each true row in a given column is feed into the individual summers feeding the inputs to the CDUCs. Below is an example of summing FDUC0,FDUC1,FDUC3 to CDDC0 and FDUC4,FDUC5 to CDDC2: tx = adi . sim . AD9081 . Tx ; tx . Crossbar8x8Mux = [ ... 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC0 -> CDUC0 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 ; ... FDUC1 -> CDUC1 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ; ... FDUC2 -> CDUC2 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 ]; % FDUC3 -> CDUC3","title":"Muxing"},{"location":"models/ad9081/duc.tex/#nco-frequency-and-phase","text":"Once the NCOs are enabled the frequencies and phases of the NCOs can be controlled individually. This is done through the CDUCNCOFrequencies, FDUCNCOFrequencies , CDUCNCOPhases , and FDUCNCOPhases . The frequencies will be limited based on the rate going into the NCO at that stage. help adi . sim . AD9081 . Tx . CDUCNCOFrequencies CDUCNCOFrequencies CDUC NCO Frequencies 1x4 Array of frequencies of NCOs in main data path help adi . sim . AD9081 . Tx . FDUCNCOFrequencies FDUCNCOFrequencies FDUC NCO Frequencies 1x8 Array of frequencies of NCOs in channelizer path","title":"NCO Frequency and Phase"},{"location":"models/ad9081/pfilt.tex/","text":"AD9081 Programmable FIR Filters (PFILT) Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path. There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0 Top-Level Control RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode , PFilterXTaps , and PFilterXGains . Operational Modes and Features Each PFILT block is fundamentally a large 192 tap filter which can be split into: 1 192 tap filter 2 96 tap filters 3 64 tap filters (Matrix filter only) 4 48 tap filters The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes: x1: first input x2: second input y1: first output y2: second output F1: filter 1 F2: filter 2 F3: filter 3 F4: filter 4 p: length of filters (individually) The different operational modes selectable through the PFilterXMode property are: NoFilter : y1 = x1, y2 = x2, y3 = x2, y4 = x2 SingleInphase : y1 = F1(x1), y2 = x2 SingleQuadrature : y1 = x1, y2 = F1(x2) DualReal : y1 = F1(x1), y2 = F2(x2) HalfComplexSumInphase : y1 = F1(x1)+F2(x1), y2 = x2*z^-p HalfComplexSumQuadrature : y2 = F1(x1)+F2(x1), y1 = x1*z^-p FullComplex : y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2) Matrix : y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2) Example Configuration Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs. rx = adi . sim . AD9081 . Rx ; rx . PFIREnable = 1 ; rx . PFilter1Mode = 'SingleInphase' ; rx . PFilter2Mode = 'NoFilter' ; N = 48 ; rx . PFilter1Taps = [ ones ( 1 , N ) ./ 2 ^ 3 , zeros ( 1 , 192 - N )]; rx . PFilter1TapsWidthsPerQuad = [ ... 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , ... 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , ... 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 ]; ... rampVolts = 1.0 * [( 1. / 1e3 .* ( 1 : 1e3 )) . ';(1./1e3.*(1e3:-1:1)).' ]; rampVolts = randn ( size ( rampVolts )) ./ 16 + rampVolts ; [ out1 , out2 , ~ , ~ , out3 , out4 ] = rx ( rampVolts , rampVolts , rampVolts , rampVolts ); outs = [ out1 , out2 , out3 , out4 ]; n = 1 : 2e3 ; subplot ( 2 , 1 , 1 ); plot ( n , real ( outs (:, 1 ))); title ( \"Moving Average Filter\" ) subplot ( 2 , 1 , 2 ); plot ( n , real ( outs (:, 2 ))); title ( \"No Filter\" )","title":"PFILT"},{"location":"models/ad9081/pfilt.tex/#ad9081-programmable-fir-filters-pfilt","text":"Following the ADCs are the Programmable FIRs (PFILTs) that can operate at maximum rates of the RX paths. The PFILTs are useful for channel equalization, image rejection, and generic filtering. The PFILTs also act as muxes into the CDDCs connected downstream on the RX path. There are two PFILT blocks per AD9081 which operate on pairs of ADCs. The ADC pairs can be individually muxed based on requirements with Mux0","title":"AD9081 Programmable FIR Filters (PFILT)"},{"location":"models/ad9081/pfilt.tex/#top-level-control","text":"RX has a pair of PFILT each which are denoted by PFilterX, where X is 1 or 2 in the property listing. Therefore RX will have properties: PFilterXMode , PFilterXTaps , and PFilterXGains .","title":"Top-Level Control"},{"location":"models/ad9081/pfilt.tex/#operational-modes-and-features","text":"Each PFILT block is fundamentally a large 192 tap filter which can be split into: 1 192 tap filter 2 96 tap filters 3 64 tap filters (Matrix filter only) 4 48 tap filters The filters are individually mapped to pairs of ADCs on the RX side based on the mode used. The PFILTs have eight configuration modes and the following notation will be used to describe the filtering modes: x1: first input x2: second input y1: first output y2: second output F1: filter 1 F2: filter 2 F3: filter 3 F4: filter 4 p: length of filters (individually) The different operational modes selectable through the PFilterXMode property are: NoFilter : y1 = x1, y2 = x2, y3 = x2, y4 = x2 SingleInphase : y1 = F1(x1), y2 = x2 SingleQuadrature : y1 = x1, y2 = F1(x2) DualReal : y1 = F1(x1), y2 = F2(x2) HalfComplexSumInphase : y1 = F1(x1)+F2(x1), y2 = x2*z^-p HalfComplexSumQuadrature : y2 = F1(x1)+F2(x1), y1 = x1*z^-p FullComplex : y1 = F1(x1)-F3(x2), y2 = F1(x1)+F3(x2)-F2(x1+x2) Matrix : y1 = F1(x1) - F3(x2), y2 = F2(x1) - F4(x2)","title":"Operational Modes and Features"},{"location":"models/ad9081/pfilt.tex/#example-configuration","text":"Here is a basic example of a moving average filter applied on the RX path on one of the four ADCs. rx = adi . sim . AD9081 . Rx ; rx . PFIREnable = 1 ; rx . PFilter1Mode = 'SingleInphase' ; rx . PFilter2Mode = 'NoFilter' ; N = 48 ; rx . PFilter1Taps = [ ones ( 1 , N ) ./ 2 ^ 3 , zeros ( 1 , 192 - N )]; rx . PFilter1TapsWidthsPerQuad = [ ... 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , 16 , ... 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , 12 , ... 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 , 6 ]; ... rampVolts = 1.0 * [( 1. / 1e3 .* ( 1 : 1e3 )) . ';(1./1e3.*(1e3:-1:1)).' ]; rampVolts = randn ( size ( rampVolts )) ./ 16 + rampVolts ; [ out1 , out2 , ~ , ~ , out3 , out4 ] = rx ( rampVolts , rampVolts , rampVolts , rampVolts ); outs = [ out1 , out2 , out3 , out4 ]; n = 1 : 2e3 ; subplot ( 2 , 1 , 1 ); plot ( n , real ( outs (:, 1 ))); title ( \"Moving Average Filter\" ) subplot ( 2 , 1 , 2 ); plot ( n , real ( outs (:, 2 ))); title ( \"No Filter\" )","title":"Example Configuration"},{"location":"models/ad9081/top_level.tex/","text":"AD9081 Behavioral Model Introduction The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below: The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores. The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility. The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements. The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below. ADC and ADC Mux DAC Programmable FIR Filters (PFILT) Digital Down Converters Digital Up Converters Model Limitations The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device. Quick Start Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below: rx = adi . sim . AD9081 . Rx ; % Call constructor of Receiver model rx . MainDataPathDecimation = 4 ; % Set CDDC decimation to 4 % Call constructor with arguments rx = adi . sim . AD9081 . Rx ( 'MainDataPathDecimation' , 4 ); The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation . These properties are validated when update and at runtime so the model will not run in an undefined mode. On receive, the input data is assumed to be in volts and the output of the model will be in codes . Note that these are not strictly ADC codes depending on what processing is enable inside. We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable and should be relatively large for performance reasons. rx = adi . sim . AD9081 . Rx ; % Create sinewave at 50 % FSR sw = dsp . SineWave ; sw . Amplitude = 0.125 ; % volts sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); outputCodes = rx ( data .* 0.5 , data .* 0.5 , data .* 0.5 , data .* 1.1 ); % Plots plot ( real ( outputCodes )); xlabel ( 'Sample' ); ylabel ( 'Code' ); On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits. tx = adi . sim . AD9081 . Tx ; tx . MainDataPathInterpolation = 2 ; tx . ModeSelectMux = 0 ; % Set DAC inputs to real data from CDUCs. % Create sinewave at 50 % and 25 % FSR sw = dsp . SineWave ; sw . Amplitude = 2 ^ 15 * 0.5 ; % codes sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; dataS = sw (); data = int16 ( dataS ); dataHalf = int16 ( dataS .* 0.5 ); [ outputCodes0 , ~ , ~ , outputCodes3 ] = tx ( data , data , data , dataHalf , data , data , data , data ); % Plots plot ( real ( outputCodes0 )); hold on ; plot ( real ( outputCodes3 )); hold off ; xlabel ( 'Sample' ); ylabel ( 'Code' ); Inspecting Properties When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups: help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] rx = adi . sim . AD9081 . Rx rx = adi.sim.AD9081.Rx with properties: CDDCNCOFrequencies: [1000000 1000000 1000000 1000000] CDDCNCOEnable: [0 0 0 0] FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000] FDDCNCOEnable: [0 0 0 0 0 0 0 0] MainDataPathDecimation: 1 ChannelizerPathDecimation: 1 Crossbar4x4Mux0: [1 2 3 4] Crossbar4x8Mux2: [1 2 1 2 3 4 3 4] PFIREnable: false ModeSelectMux1: false SampleRate: 4.0000e+09 help rx . MainDataPathDecimation --- help for adi.sim.AD9081.Rx/MainDataPathDecimation --- MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6]","title":"Overview"},{"location":"models/ad9081/top_level.tex/#ad9081-behavioral-model-introduction","text":"The AD9081 is a highly integrated RF mixed-signal front-end (MxFE) that features four 16-bit, 12 GSPS DAC cores and four 12-bit, 4 GSPS ADC cores, as shown below: The device includes an optional on-chip clock multiplier (up to 12GHz) for DAC and ADC sampling clock generation as well as broadband ADC and DAC cores. The transmit and receive digital datapaths are highly configurable and support a wide range of single-band and multiband applications with varying RF bandwidth requirements. The AD9081 transmit and receive datapaths consist of four main datapaths in support of wideband signals and eight channelizers in support of narrower band signals. For multiband applications with wide separation between RF bands, the channelizers can be used to process the individual RF bands to reduce the overall complex data rate needed to represent each narrower band. Both the main and channelizer datapath stages offer flexible interpolating and decimation factors to allow a more manageable data interface rate aligned to the actual signal bandwidth requirements. The numerically controlled oscillator of each stage can be independently tuned for maximum flexibility. The models available in the High-Speed Converter Toolbox are designed to educate users on the configuration, features, and limitations of the AD9081. However, it should not be expected to match hardware exactly, but be similar in behavior. It should not be used for exact performance measurements. The device model is split into two components, one modeling the transmit path and one for the receive path. Both are System Objects and have methods and properties to allow configuration and passing of data into the models. For details on the different features select from the links below. For a basic overview of the models go to the \\hyperref{H_C9E8316D}{Quick Start} section below. ADC and ADC Mux DAC Programmable FIR Filters (PFILT) Digital Down Converters Digital Up Converters","title":"AD9081 Behavioral Model Introduction"},{"location":"models/ad9081/top_level.tex/#model-limitations","text":"The models are primarily designed to expose the DSP features of AD9081 and the different configurations possible. This does not include the JESD interfaces or highly detailed implementation of the ADCs or DACs within the device. However, the converter models will have similar NSD performance of the device.","title":"Model Limitations"},{"location":"models/ad9081/top_level.tex/#quick-start","text":"Each TX and RX model instance can be instantiated like any other System Object in MATLAB through the constructor call. The constructor can be used to parameterize the model but it is typically more understandable to do this separately from the constructor as below: rx = adi . sim . AD9081 . Rx ; % Call constructor of Receiver model rx . MainDataPathDecimation = 4 ; % Set CDDC decimation to 4 % Call constructor with arguments rx = adi . sim . AD9081 . Rx ( 'MainDataPathDecimation' , 4 ); The receiver model has dozens of properties and are set in a similar way to the above MainDataPathDecimation . These properties are validated when update and at runtime so the model will not run in an undefined mode. On receive, the input data is assumed to be in volts and the output of the model will be in codes . Note that these are not strictly ADC codes depending on what processing is enable inside. We can demonstrate a typical usage flow of the receiver through a few examples. In the below example feeds a 50% fullscale and 110% fullscale signal into the four ADCs in the form of a matrix. The input to the RX model must always be a 4 real Nx1 arrays of type double, representing the input to each ADC. N must be a multiple of the total decimation enable and should be relatively large for performance reasons. rx = adi . sim . AD9081 . Rx ; % Create sinewave at 50 % FSR sw = dsp . SineWave ; sw . Amplitude = 0.125 ; % volts sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; data = sw (); outputCodes = rx ( data .* 0.5 , data .* 0.5 , data .* 0.5 , data .* 1.1 ); % Plots plot ( real ( outputCodes )); xlabel ( 'Sample' ); ylabel ( 'Code' ); On the TX side the usage model is the same, but we are instead passing integers to be transmitted from the DACs and the outputs are codes to the relative fullscale of the DAC which is 16-bits. tx = adi . sim . AD9081 . Tx ; tx . MainDataPathInterpolation = 2 ; tx . ModeSelectMux = 0 ; % Set DAC inputs to real data from CDUCs. % Create sinewave at 50 % and 25 % FSR sw = dsp . SineWave ; sw . Amplitude = 2 ^ 15 * 0.5 ; % codes sw . Frequency = 10e6 ; sw . SampleRate = rx . SampleRate ; sw . SamplesPerFrame = 4e4 ; dataS = sw (); data = int16 ( dataS ); dataHalf = int16 ( dataS .* 0.5 ); [ outputCodes0 , ~ , ~ , outputCodes3 ] = tx ( data , data , data , dataHalf , data , data , data , data ); % Plots plot ( real ( outputCodes0 )); hold on ; plot ( real ( outputCodes3 )); hold off ; xlabel ( 'Sample' ); ylabel ( 'Code' );","title":"Quick Start"},{"location":"models/ad9081/top_level.tex/#inspecting-properties","text":"When using the model individual properties can be inspected for their functionality. Leveraging the help command will print out useful information on each setting. Follow the patterns below to perform lookups: help adi . sim . AD9081 . Rx . MainDataPathDecimation MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6] rx = adi . sim . AD9081 . Rx rx = adi.sim.AD9081.Rx with properties: CDDCNCOFrequencies: [1000000 1000000 1000000 1000000] CDDCNCOEnable: [0 0 0 0] FDDCNCOFrequencies: [1000000 1000000 1000000 1000000 1000000 1000000 1000000 1000000] FDDCNCOEnable: [0 0 0 0 0 0 0 0] MainDataPathDecimation: 1 ChannelizerPathDecimation: 1 Crossbar4x4Mux0: [1 2 3 4] Crossbar4x8Mux2: [1 2 1 2 3 4 3 4] PFIREnable: false ModeSelectMux1: false SampleRate: 4.0000e+09 help rx . MainDataPathDecimation --- help for adi.sim.AD9081.Rx/MainDataPathDecimation --- MainDataPathDecimation Main Data Path Decimation Specify the decimation in the main data path which can be [1,2,3,4,6]","title":"Inspecting Properties"},{"location":"sysobjects/adi.AD9081.Rx/","text":"The adi.AD9081.Rx System object is a signal source that can receive complex data from the AD9081. rx = adi.AD9081.Rx; rx = adi.AD9081.Rx('uri','ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9081 . Rx dev = adi . AD9081 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is only readable once connected to hardware ChannelNCOFrequencies + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequencies + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhases + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhases + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. TestMode + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' EnablePFIRs + Enable use of PFIR/PFILT filters PFIRFilenames + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Rx/SamplesPerFrame is inherited from superclass adi.AD9081.Base EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Rx/uri is inherited from superclass matlabshared.libiio.base Example Usage %% Rx set up rx = adi.AD9081.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9081.Rx"},{"location":"sysobjects/adi.AD9081.Tx/","text":"The adi.AD9081.Tx System object is a signal sink that can tranmsit complex data from the AD9081. tx = adi.AD9081.Tx; tx = adi.AD9081.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9081 . Tx dev = adi . AD9081 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequencies + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequencies + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhases + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhases + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScales + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. NCOEnables + Vector of logicals which enabled individual NCOs in channel interpolators SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9081.Tx/SamplesPerFrame is inherited from superclass adi.AD9081.Base EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9081.Tx/uri is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9081.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9081.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9081.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS Example Usage %% Configure device tx = adi.AD9081.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.ComplexOutput = true; swv1.SamplesPerFrame = 2^14; swv1.SampleRate = 250e6; y = swv1(); %% Send tx(y);","title":"adi.AD9081.Tx"},{"location":"sysobjects/adi.AD9083.Rx/","text":"The adi.AD9083.Rx System object is a signal source that can receive data from the AD9083. rx = adi.AD9083.Rx; rx = adi.AD9083.Rx('uri','ip:192.168.2.1'); AD9083 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9083 . Rx dev = adi . AD9083 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9083.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9083.Rx/SamplesPerFrame is inherited from superclass adi.AD9083.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.AD9083.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.AD9083.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9083.Rx/SamplesPerFrame is inherited from superclass adi.AD9083.Base Example Usage %% Rx set up rx = adi.AD9083.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9083.Rx"},{"location":"sysobjects/adi.AD9144.Tx/","text":"The adi.AD9144.Tx System object is a signal source that can send complex data from the AD9144. tx = adi.AD9144.Tx; tx = adi.AD9144.Tx('uri','ip:192.168.2.1'); AD9144 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9144 . Tx dev = adi . AD9144 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9144.Tx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9144.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.AD9144.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.AD9144.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9144.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9144.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9144.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9144.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base Example Usage %% Configure device tx = adi.AD9144.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.AD9144.Tx"},{"location":"sysobjects/adi.AD9152.Tx/","text":"The adi.AD9152.Tx System object is a signal source that can send complex data from the AD9144. tx = adi.AD9144.Tx; tx = adi.AD9144.Tx('uri','ip:ip:192.168.2.1'); AD9144 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9152 . Tx dev = adi . AD9152 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9152.Tx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9152.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.AD9152.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.AD9152.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.AD9152.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.AD9152.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.AD9152.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9152.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base Example Usage %% Configure device tx = adi.AD9152.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.AD9152.Tx"},{"location":"sysobjects/adi.AD9213.Rx/","text":"The adi.AD9213.Rx System object is a signal source that can receive complex data from the AD9213. rx = adi.AD9213.Rx; rx = adi.AD9213.Rx('uri','ip:192.168.2.1'); AD9213 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9213 . Rx dev = adi . AD9213 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9213.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.AD9213.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.AD9213.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base Example Usage %% Rx set up rx = adi.AD9213.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9213.Rx"},{"location":"sysobjects/adi.AD9467.Rx/","text":"The adi.AD9467.Rx System object is a signal source that can receive complex data from the AD9467. rx = adi.AD9467.Rx; rx = adi.AD9467.Rx('uri','ip:192.168.2.1'); AD9467 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9467 . Rx dev = adi . AD9467 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value read from the hardware after the object is setup. TestMode + Select ADC test mode. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn_long' 'pn_short' 'one_zero_toggle' FilterHighPass3dbFrequency + FilterHighPass3dbFrequency Scale + Scale received data. Possible options are: 0.030517 0.032043 0.033569 0.035095 0.036621 0.038146 SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9467.Rx/SamplesPerFrame is inherited from superclass adi.AD9467.Base EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9467.Rx/uri is inherited from superclass matlabshared.libiio.base Example Usage %% Rx set up rx = adi.AD9467.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9467.Rx"},{"location":"sysobjects/adi.AD9680.Rx/","text":"The adi.AD9680.Rx System object is a signal source that can receive complex data from the AD9680. rx = adi.AD9680.Rx; rx = adi.AD9680.Rx('uri','ip:192.168.2.1'); AD9680 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . AD9680 . Rx dev = adi . AD9680 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constant EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.AD9680.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9680.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.AD9680.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.AD9680.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.AD9680.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base Example Usage %% Rx set up rx = adi.AD9680.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.AD9680.Rx"},{"location":"sysobjects/adi.DAQ2.Rx/","text":"The adi.DAQ2.Rx System object is a signal source that can receive complex data from the DAQ2. rx = adi.DAQ2.Rx; rx = adi.DAQ2.Rx('uri','ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ2 . Rx dev = adi . DAQ2 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Rx/SamplingRate is inherited from superclass adi.AD9680.Rx EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.DAQ2.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base Example Usage %% Rx set up rx = adi.DAQ2.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.DAQ2.Rx"},{"location":"sysobjects/adi.DAQ2.Tx/","text":"The adi.DAQ2.Tx System object is a signal source that can send complex data to the DAQ2. tx = adi.DAQ2.Tx; tx = adi.DAQ2.Tx('uri','ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ2 . Tx dev = adi . DAQ2 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ2.Tx.SamplingRate is inherited from superclass adi.AD9144.Tx EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ2.Tx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ2.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.DAQ2.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ2.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ2.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ2.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ2.Tx/SamplesPerFrame is inherited from superclass adi.AD9144.Base Example Usage %% Configure device tx = adi.DAQ2.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.DAQ2.Tx"},{"location":"sysobjects/adi.DAQ3.Rx/","text":"The adi.DAQ3.Rx System object is a signal source that can receive complex data from the DAQ3. rx = adi.DAQ3.Rx; rx = adi.DAQ3.Rx('uri','ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ3 . Rx dev = adi . DAQ3 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ3.Rx/SamplingRate is inherited from superclass adi.AD9680.Rx EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ3.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ3.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.DAQ3.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Rx/SamplesPerFrame is inherited from superclass adi.AD9680.Base Example Usage %% Rx set up rx = adi.DAQ3.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.DAQ3.Rx"},{"location":"sysobjects/adi.DAQ3.Tx/","text":"The adi.DAQ2.Tx System object is a signal source that can send complex data to the DAQ3. tx = adi.DAQ3.Tx; tx = adi.DAQ3.Tx('uri','ip:ip:192.168.2.1'); User Guide Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DAQ3 . Tx dev = adi . DAQ3 . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. SamplingRate + Baseband sampling rate in Hz, specified as a scalar in samples per second. This value is constantHelp for adi.DAQ3.Tx/SamplingRate is inherited from superclass adi.AD9152.Tx EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DAQ3.Tx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DAQ3.Tx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.DAQ3.Tx/dataTypeStr is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.DAQ3.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.DAQ3.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.DAQ3.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DAQ3.Tx/SamplesPerFrame is inherited from superclass adi.AD9152.Base Example Usage %% Configure device tx = adi.DAQ3.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.DAQ3.Tx"},{"location":"sysobjects/adi.DualAD9213.Rx/","text":"The adi.DualAD9213.Rx System object is a signal source that can receive complex data from the DualAD9213. rx = adi.DualAD9213.Rx; rx = adi.DualAD9213.Rx('uri','ip:ip:192.168.2.1'); AD9213 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . DualAD9213 . Rx dev = adi . DualAD9213 . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.DualAD9213.Rx/uri is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DualAD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base kernelBuffersCount + The number of buffers allocated in the kernel for data transfersHelp for adi.DualAD9213.Rx/kernelBuffersCount is inherited from superclass matlabshared.libiio.base dataTypeStr + A String Representing the data typeHelp for adi.DualAD9213.Rx/dataTypeStr is inherited from superclass matlabshared.libiio.base SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance.Help for adi.DualAD9213.Rx/SamplesPerFrame is inherited from superclass adi.AD9213.Base Example Usage %% Rx set up rx = adi.DualAD9213.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.DualAD9213.Rx"},{"location":"sysobjects/adi.QuadMxFE.Rx/","text":"The adi.QuadMxFE.Rx System object is a signal source that can receive complex data from the QuadMxFE. rx = adi.QuadMxFE.Rx; rx = adi.QuadMxFE.Rx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . QuadMxFE . Rx dev = adi . QuadMxFE . Rx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequenciesChipA + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOFrequenciesChipB + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOFrequenciesChipC + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOFrequenciesChipD + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequenciesChipA + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequenciesChipB + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequenciesChipC + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOFrequenciesChipD + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhasesChipA + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhasesChipB + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhasesChipC + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. ChannelNCOPhasesChipD + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhasesChipA + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhasesChipB + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhasesChipC + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. MainNCOPhasesChipD + Frequency of NCO in fine decimators in receive path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz, and N is the number of channels available. TestModeChipA + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' TestModeChipB + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' TestModeChipC + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' TestModeChipD + Test mode of receive path. Options are: 'off' 'midscale_short' 'pos_fullscale' 'neg_fullscale' 'checkerboard' 'pn9' 'pn32' 'one_zero_toggle' 'user' 'pn7' 'pn15' 'pn31' 'ramp' EnablePFIRsChipA + Enable use of PFIR/PFILT filters for Chip A EnablePFIRsChipB + Enable use of PFIR/PFILT filters for Chip B EnablePFIRsChipC + Enable use of PFIR/PFILT filters for Chip C EnablePFIRsChipD + Enable use of PFIR/PFILT filters for Chip D PFIRFilenamesChipA + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip A PFIRFilenamesChipB + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip B PFIRFilenamesChipC + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip C PFIRFilenamesChipD + Path(s) to FPIR/PFILT filter file(s). Input can be a string or cell array of strings. Files are loading in order for Chip D ExternalAttenuation + Attenuation value of external HMC425a SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableResampleFilters + Enable interpolation (TX) or decimation (RX) by 2 when enabled to correct interface rate to 125 MS/s. This will scale the input and output data length by either 1/2 (RX) or 2 (TX). CalibrationBoardAttached + EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.QuadMxFE.Rx/uri is inherited from superclass matlabshared.libiio.base Example Usage %% Rx set up rx = adi.QuadMxFE.Rx('uri','ip:analog.local'); rx.SamplesPerFrame = 2^14; rx.EnabledChannels = 1; %% Run for k=1:10 valid = false; while ~valid [out, valid] = rx(); end end %% Cleanup release(rx)","title":"adi.QuadMxFE.Rx"},{"location":"sysobjects/adi.QuadMxFE.Tx/","text":"The adi.QuadMxFE.Tx System object is a signal sink that can tranmsit complex data from the QuadMxFE. tx = adi.QuadMxFE.Tx; tx = adi.QuadMxFE.Tx('uri','ip:ip:192.168.2.1'); AD9081 Datasheet Creation The class can be instantiated in the following way with and without property name value pairs. dev = adi . QuadMxFE . Tx dev = adi . QuadMxFE . Tx ( Name , Value ) Properties Unless otherwise indicated, properties are non-tunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. ChannelNCOFrequenciesChipA + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOFrequenciesChipB + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOFrequenciesChipC + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOFrequenciesChipD + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequenciesChipA + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequenciesChipB + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequenciesChipC + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOFrequenciesChipD + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhasesChipA + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhasesChipB + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhasesChipC + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOPhasesChipD + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhasesChipA + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhasesChipB + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhasesChipC + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. MainNCOPhasesChipD + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScalesChipA + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScalesChipB + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScalesChipC + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. ChannelNCOGainScalesChipD + Frequency of NCO in fine decimators in transmit path. Property must be a [1,N] vector where each value is the frequency of an NCO in hertz. NCOEnablesChipA + Vector of logicals which enabled individual NCOs in channel interpolators NCOEnablesChipB + Vector of logicals which enabled individual NCOs in channel interpolators NCOEnablesChipC + Vector of logicals which enabled individual NCOs in channel interpolators NCOEnablesChipD + Vector of logicals which enabled individual NCOs in channel interpolators UpdateDACFullScaleCurrent + At initialization update DAC full scale current DACFullScaleCurrentuA + DAC full scale current in microamps. Only used when UpdateDACFullScaleCurrent is set. SamplesPerFrame + Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableResampleFilters + Enable interpolation (TX) or decimation (RX) by 2 when enabled to correct interface rate to 125 MS/s. This will scale the input and output data length by either 1/2 (RX) or 2 (TX). CalibrationBoardAttached + EnabledChannels + Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri + Hostname or IP address of remote libIIO deviceHelp for adi.QuadMxFE.Tx/uri is inherited from superclass matlabshared.libiio.base DataSource + Data source, specified as one of the following: 'DMA' \u2014 Specify the host as the source of the data. 'DDS' \u2014 Specify the DDS on the radio hardware as the source of the data. In this case, each channel has two additive tones.Help for adi.QuadMxFE.Tx/DataSource is inherited from superclass adi.common.DDS DDSFrequencies + Frequencies values in Hz of the DDS tone generators. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSFrequencies is inherited from superclass adi.common.DDS DDSScales + Scale of DDS tones in range [0,1]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSScales is inherited from superclass adi.common.DDS DDSPhases + Phases of DDS tones in range [0,360000]. For complex data devices the input is a [2xN] matrix where N is the available channels on the board. For complex data devices this is at most max(EnabledChannels)*2. For non-complex data devices this is at most max(EnabledChannels). If N < this upper limit, other DDSs are not set.Help for adi.QuadMxFE.Tx/DDSPhases is inherited from superclass adi.common.DDS EnableCyclicBuffers + Enable Cyclic Buffers, configures transmit buffers to be cyclic, which makes them continuously repeatHelp for adi.QuadMxFE.Tx/EnableCyclicBuffers is inherited from superclass adi.common.DDS Example Usage %% Configure device tx = adi.QuadMxFE.Tx; tx.uri = \"ip:analog.local\"; tx.DataSource = 'DMA'; tx.EnableCyclicBuffers = true; tx.EnabledChannels = 1; %% Generate tone amplitude = 2^15; frequency = 0.12e6; swv1 = dsp.SineWave(amplitude, frequency); swv1.SamplesPerFrame = 2^14; swv1.SampleRate = tx.SamplingRate; y = swv1(); %% Send tx(y);","title":"adi.QuadMxFE.Tx"},{"location":"sysobjects/output1/","text":"adi.Pluto.Rx Receive data from Analog Devices AD9361 transceiver Description The comm.SDRRxPluto System object\u2122 is a signal source that receives data from an Analog Devices\u00ae ADALM-PLUTO radio. This connection enables you to simulate and develop various software-defined radio applications. The following diagram shows the interaction between MATLAB\u00ae, the comm.SDRRxPluto System object, and the radio hardware. Creation Syntax Properties Unless otherwise indicated, properties are nontunable, which means you cannot change their values after calling the object. Objects lock when you call them, and the release function unlocks them. If a property is tunable, you can change its value at any time. For more information on changing property values, see System Design in MATLAB Using System Objects. CenterFrequency RF center frequency, specified in Hz as a scalar. The default is 2.4e9. This property is tunable.Help for adi.Pluto.Rx/CenterFrequency is inherited from superclass ADI.AD9361.RX SamplingRate Baseband sampling rate in Hz, specified as a scalar from 65105 to 61.44e6 samples per second.Help for adi.Pluto.Rx/SamplingRate is inherited from superclass ADI.AD9361.RX RFBandwidth RF Bandwidth of front-end analog filter in Hz, specified as a scalar from 200 kHz to 56 MHz.Help for adi.Pluto.Rx/RFBandwidth is inherited from superclass ADI.AD9361.RX GainControlModeChannel0 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel0 is inherited from superclass ADI.AD9361.RX GainChannel0 Channel 0 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel0 is inherited from superclass ADI.AD9361.RX GainControlModeChannel1 specified as one of the following: 'slow_attack' \u2014 For signals with slowly changing power levels 'fast_attack' \u2014 For signals with rapidly changing power levels 'manual' \u2014 For setting the gain manually with the Gain property 'hybrid' \u2014 For configuring hybrid AGC modeHelp for adi.Pluto.Rx/GainControlModeChannel1 is inherited from superclass ADI.AD9361.RX GainChannel1 Channel 1 gain, specified as a scalar from -3 dB to 71 dB. The acceptable minimum and maximum gain setting depends on the center frequency.Help for adi.Pluto.Rx/GainChannel1 is inherited from superclass ADI.AD9361.RX LoopbackMode Option to set digital loopback mode, specified as 0, 1 or 2. Allows either to digitally loopback TX data into the RX path or vice versa. Value | Mode --------------------------- 0 | Disable 1 | Digital TX -> Digital RX 2 | RF RX -> RF TX Help for adi.Pluto.Rx/LoopbackMode is inherited from superclass ADI.AD9361.RX EnableQuadratureTracking Option to enable quadrature tracking, specified as true or false. When this property is true, IQ imbalance compensation is applied to the input signal.Help for adi.Pluto.Rx/EnableQuadratureTracking is inherited from superclass ADI.AD9361.RX EnableRFDCTracking Option to enable RF DC tracking, specified as true or false. When this property is true, an RF DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableRFDCTracking is inherited from superclass ADI.AD9361.RX EnableBasebandDCTracking Option to enable baseband DC tracking, specified as true or false. When this property is true, a baseband DC blocking filter is applied to the input signal.Help for adi.Pluto.Rx/EnableBasebandDCTracking is inherited from superclass ADI.AD9361.RX RFPortSelect 'A_BALANCED' 'B_BALANCED' 'C_BALANCED' 'A_N' 'A_P' 'B_N' 'B_P' 'C_N' 'C_P' 'TX_MONITOR1' 'TX_MONITOR2' 'TX_MONITOR1_2'Help for adi.Pluto.Rx/RFPortSelect is inherited from superclass ADI.AD9361.RX SamplesPerFrame Number of samples per frame, specified as an even positive integer from 2 to 16,777,216. Using values less than 3660 can yield poor performance. EnableCustomFilter Enable use of custom filter file to set SamplingRate, RFBandwidth, and FIR in datapaths CustomFilterFileName Path to custom filter file created from filter wizard EnabledChannels Indexs of channels to be enabled. Input should be a [1xN] vector with the indexes of channels to be enabled. Order is irrelevant uri Hostname or IP address of remote libIIO deviceHelp for adi.Pluto.Rx/uri is inherited from superclass MATLABSHARED.LIBIIO.BASE enIO If true, connects to libIIO device during simulationHelp for adi.Pluto.Rx/enIO is inherited from superclass MATLABSHARED.LIBIIO.BASE","title":"Output1"}]}